CREATE TABLE "HISTORY_PERIOD_BAK"
   (	"PK" VARCHAR2(32 BYTE),
	"DT_BEGIN" DATE NOT NULL,
	"DT_END" DATE NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "FRAME_HISTORY"
   (	"PK_FRAME_HISTORY" RAW(16) DEFAULT sys_guid() NOT NULL,
	"PK_FRAME" VARCHAR2(36 BYTE) NOT NULL,
	"PK_LAYER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(256 BYTE) NOT NULL,
	"STR_STATE" VARCHAR2(24 BYTE) NOT NULL,
	"INT_MEM_RESERVED" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_MEM_MAX_USED" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_CORES" NUMBER(16,0) DEFAULT 100 NOT NULL,
	"STR_HOST" VARCHAR2(64 BYTE) DEFAULT NULL,
	"INT_EXIT_STATUS" NUMBER(8,0) DEFAULT -1 NOT NULL,
	"PK_ALLOC" VARCHAR2(36 BYTE),
	"INT_TS_STARTED" NUMBER(12,0) NOT NULL,
	"INT_TS_STOPPED" NUMBER(12,0) DEFAULT 0 NOT NULL,
	"INT_CHECKPOINT_COUNT" NUMBER(6,0) DEFAULT 0 NOT NULL,
	"DT_LAST_MODIFIED" DATE NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "HISTORY_PERIOD"
   (	"PK" VARCHAR2(32 BYTE) DEFAULT sys_guid(),
	"DT_BEGIN" DATE DEFAULT to_date('01-JAN-2000','DD-MON-YYYY') NOT NULL,
	"DT_END" DATE DEFAULT sysdate NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "DUPLICATE_CURSORS"
   (	"DT_RECORDED" DATE,
	"INST_ID" NUMBER,
	"LNG_COUNT" NUMBER
   )
-- SPLIT HERE!
CREATE TABLE "UNCOMMITTED_TRANSACTIONS_BAK"
   (	"INST_ID" NUMBER,
	"SID" NUMBER,
	"SERIAL#" NUMBER,
	"USERNAME" VARCHAR2(30 BYTE),
	"MACHINE" VARCHAR2(64 BYTE),
	"MODULE" VARCHAR2(48 BYTE),
	"SERVICE_NAME" VARCHAR2(64 BYTE),
	"DURATION" NUMBER,
	"DT_RECORDED" DATE
   )
-- SPLIT HERE!
CREATE TABLE "UNCOMMITTED_TRANSACTIONS"
   (	"INST_ID" NUMBER,
	"SID" NUMBER,
	"SERIAL#" NUMBER,
	"USERNAME" VARCHAR2(30 BYTE),
	"MACHINE" VARCHAR2(64 BYTE),
	"MODULE" VARCHAR2(48 BYTE),
	"SERVICE_NAME" VARCHAR2(64 BYTE),
	"DURATION" NUMBER,
	"DT_RECORDED" DATE DEFAULT sysdate
   )
-- SPLIT HERE!
CREATE TABLE "TEST"
   (	"COL1" VARCHAR2(32 BYTE)
   )
-- SPLIT HERE!
CREATE TABLE "LAYER_OUTPUT"
   (	"PK_LAYER_OUTPUT" VARCHAR2(36 BYTE) NOT NULL,
	"PK_LAYER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"STR_FILESPEC" VARCHAR2(2048 BYTE) NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "SHOW_SERVICE"
   (	"PK_SHOW_SERVICE" VARCHAR2(36 BYTE) NOT NULL,
	"PK_SHOW" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(36 BYTE) NOT NULL,
	"B_THREADABLE" NUMBER(1,0) NOT NULL,
	"INT_CORES_MIN" NUMBER(8,0) NOT NULL,
	"INT_MEM_MIN" NUMBER(16,0) NOT NULL,
	"STR_TAGS" VARCHAR2(128 BYTE) NOT NULL,
	"INT_CORES_MAX" NUMBER(10,0) DEFAULT 0 NOT NULL,
	"INT_GPU_MIN" NUMBER(10,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "SQLN_EXPLAIN_PLAN"
   (	"STATEMENT_ID" VARCHAR2(30 BYTE),
	"TIMESTAMP" DATE,
	"REMARKS" VARCHAR2(80 BYTE),
	"OPERATION" VARCHAR2(30 BYTE),
	"OPTIONS" VARCHAR2(30 BYTE),
	"OBJECT_NODE" VARCHAR2(128 BYTE),
	"OBJECT_OWNER" VARCHAR2(30 BYTE),
	"OBJECT_NAME" VARCHAR2(30 BYTE),
	"OBJECT_INSTANCE" NUMBER(*,0),
	"OBJECT_TYPE" VARCHAR2(30 BYTE),
	"OPTIMIZER" VARCHAR2(255 BYTE),
	"SEARCH_COLUMNS" NUMBER(*,0),
	"ID" NUMBER(*,0),
	"PARENT_ID" NUMBER(*,0),
	"POSITION" NUMBER(*,0),
	"COST" NUMBER(*,0),
	"CARDINALITY" NUMBER(*,0),
	"BYTES" NUMBER(*,0),
	"OTHER_TAG" VARCHAR2(255 BYTE),
	"PARTITION_START" VARCHAR2(255 BYTE),
	"PARTITION_STOP" VARCHAR2(255 BYTE),
	"PARTITION_ID" NUMBER(*,0),
	"OTHER" LONG,
	"DISTRIBUTION" VARCHAR2(30 BYTE)
   )
-- SPLIT HERE!
CREATE TABLE "DEED"
   (	"PK_DEED" VARCHAR2(36 BYTE) NOT NULL,
	"PK_OWNER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_HOST" VARCHAR2(36 BYTE) NOT NULL,
	"B_BLACKOUT" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"INT_BLACKOUT_START" NUMBER(12,0),
	"INT_BLACKOUT_STOP" NUMBER(12,0)
   )
-- SPLIT HERE!
CREATE TABLE "OWNER"
   (	"PK_OWNER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_SHOW" VARCHAR2(36 BYTE) NOT NULL,
	"STR_USERNAME" VARCHAR2(64 BYTE) NOT NULL,
	"TS_CREATED" TIMESTAMP (6) WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
	"TS_UPDATED" TIMESTAMP (6) WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "HOST_LOCAL"
   (	"PK_HOST_LOCAL" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"PK_LAYER" VARCHAR2(36 BYTE),
	"PK_FRAME" VARCHAR2(36 BYTE),
	"PK_HOST" VARCHAR2(36 BYTE) NOT NULL,
	"TS_CREATED" TIMESTAMP (6) WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
	"TS_UPDATED" TIMESTAMP (6) WITH TIME ZONE,
	"INT_MEM_MAX" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_MEM_IDLE" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_CORES_MAX" NUMBER(16,0) DEFAULT 100 NOT NULL,
	"INT_CORES_IDLE" NUMBER(16,0) DEFAULT 100 NOT NULL,
	"INT_THREADS" NUMBER(4,0) DEFAULT 1 NOT NULL,
	"FLOAT_TIER" NUMBER(16,2) DEFAULT 0 NOT NULL,
	"B_ACTIVE" NUMBER(1,0) DEFAULT 1 NOT NULL,
	"STR_TYPE" VARCHAR2(36 BYTE) NOT NULL,
	"INT_GPU_IDLE" NUMBER(10,0) DEFAULT 0 NOT NULL,
	"INT_GPU_MAX" NUMBER(10,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "SERVICE"
   (	"PK_SERVICE" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(36 BYTE) NOT NULL,
	"B_THREADABLE" NUMBER(1,0) NOT NULL,
	"INT_CORES_MIN" NUMBER(8,0) NOT NULL,
	"INT_MEM_MIN" NUMBER(16,0) NOT NULL,
	"STR_TAGS" VARCHAR2(128 BYTE) NOT NULL,
	"INT_CORES_MAX" NUMBER(10,0) DEFAULT 0 NOT NULL,
	"INT_GPU_MIN" NUMBER(10,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "JOB_LOCAL"
   (	"PK_JOB_LOCAL" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"PK_HOST" VARCHAR2(36 BYTE) NOT NULL,
	"STR_SOURCE" VARCHAR2(255 BYTE) NOT NULL,
	"TS_CREATED" TIMESTAMP (6) WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
	"INT_CORES" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_MAX_CORES" NUMBER(16,0) NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "TASK"
   (	"PK_TASK" VARCHAR2(36 BYTE) NOT NULL,
	"PK_POINT" VARCHAR2(36 BYTE) NOT NULL,
	"STR_SHOT" VARCHAR2(36 BYTE) NOT NULL,
	"INT_MIN_CORES" NUMBER(16,0) DEFAULT 100 NOT NULL,
	"INT_ADJUST_CORES" NUMBER(16,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "POINT"
   (	"PK_POINT" VARCHAR2(36 BYTE) NOT NULL,
	"PK_DEPT" VARCHAR2(36 BYTE) NOT NULL,
	"PK_SHOW" VARCHAR2(36 BYTE) NOT NULL,
	"STR_TI_TASK" VARCHAR2(36 BYTE),
	"INT_CORES" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"B_MANAGED" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"INT_MIN_CORES" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"FLOAT_TIER" NUMBER(16,2) DEFAULT 0 NOT NULL,
	"TS_UPDATED" TIMESTAMP (6) WITH TIME ZONE DEFAULT systimestamp NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "LAYER_MEM"
   (	"PK_LAYER_MEM" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"PK_LAYER" VARCHAR2(36 BYTE) NOT NULL,
	"INT_MAX_RSS" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_MAX_VSS" NUMBER(16,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "JOB_MEM"
   (	"PK_JOB_MEM" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"INT_MAX_RSS" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_MAX_VSS" NUMBER(16,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "FOLDER_RESOURCE"
   (	"PK_FOLDER_RESOURCE" VARCHAR2(36 BYTE) NOT NULL,
	"PK_FOLDER" VARCHAR2(36 BYTE) NOT NULL,
	"INT_CORES" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_MAX_CORES" NUMBER(16,0) DEFAULT -1 NOT NULL,
	"INT_MIN_CORES" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"FLOAT_TIER" NUMBER(16,2) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "SHOW_ALIAS"
   (	"PK_SHOW_ALIAS" VARCHAR2(36 BYTE) NOT NULL,
	"PK_SHOW" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(16 BYTE) NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "DEPT"
   (	"PK_DEPT" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(36 BYTE) NOT NULL,
	"B_DEFAULT" NUMBER(1,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "FACILITY"
   (	"PK_FACILITY" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(36 BYTE) NOT NULL,
	"B_DEFAULT" NUMBER(1,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "JOB_POST"
   (	"PK_JOB_POST" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"PK_POST_JOB" VARCHAR2(36 BYTE) NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "LAYER_HISTORY"
   (	"PK_LAYER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(512 BYTE) NOT NULL,
	"STR_TYPE" VARCHAR2(16 BYTE) NOT NULL,
	"INT_CORES_MIN" NUMBER(38,0) DEFAULT 100 NOT NULL,
	"INT_MEM_MIN" NUMBER(38,0) DEFAULT 4194304 NOT NULL,
	"INT_CORE_TIME_SUCCESS" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_CORE_TIME_FAIL" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_FRAME_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_LAYER_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_WAITING_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_DEAD_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_DEPEND_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_EATEN_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_SUCCEEDED_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_RUNNING_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_MAX_RSS" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"B_ARCHIVED" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"DT_LAST_MODIFIED" DATE NOT NULL,
	"STR_SERVICES" VARCHAR2(128)
   )
-- SPLIT HERE!
CREATE TABLE "JOB_HISTORY"
   (	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"PK_SHOW" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(512 BYTE) NOT NULL,
	"STR_SHOT" VARCHAR2(64 BYTE) NOT NULL,
	"STR_USER" VARCHAR2(36 BYTE) NOT NULL,
	"INT_CORE_TIME_SUCCESS" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_CORE_TIME_FAIL" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_FRAME_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_LAYER_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_WAITING_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_DEAD_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_DEPEND_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_EATEN_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_SUCCEEDED_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_RUNNING_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_MAX_RSS" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"B_ARCHIVED" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"PK_FACILITY" VARCHAR2(36 BYTE) NOT NULL,
	"PK_DEPT" VARCHAR2(36 BYTE) NOT NULL,
	"INT_TS_STARTED" NUMBER(12,0) NOT NULL,
	"INT_TS_STOPPED" NUMBER(12,0) DEFAULT 0 NOT NULL,
	"DT_LAST_MODIFIED" DATE NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "TASK_LOCK"
   (	"PK_TASK_LOCK" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(36 BYTE) NOT NULL,
	"INT_LOCK" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_TIMEOUT" NUMBER(38,0) DEFAULT 30 NOT NULL,
	"TS_LASTRUN" TIMESTAMP (6) DEFAULT systimestamp NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "MATTHEW_STATS_TAB"
   (	"STATID" VARCHAR2(30 BYTE),
	"TYPE" CHAR(1 BYTE),
	"VERSION" NUMBER,
	"FLAGS" NUMBER,
	"C1" VARCHAR2(30 BYTE),
	"C2" VARCHAR2(30 BYTE),
	"C3" VARCHAR2(30 BYTE),
	"C4" VARCHAR2(30 BYTE),
	"C5" VARCHAR2(30 BYTE),
	"N1" NUMBER,
	"N2" NUMBER,
	"N3" NUMBER,
	"N4" NUMBER,
	"N5" NUMBER,
	"N6" NUMBER,
	"N7" NUMBER,
	"N8" NUMBER,
	"N9" NUMBER,
	"N10" NUMBER,
	"N11" NUMBER,
	"N12" NUMBER,
	"D1" DATE,
	"R1" RAW(32),
	"R2" RAW(32),
	"CH1" VARCHAR2(1000 BYTE)
   )
-- SPLIT HERE!
CREATE TABLE "HOST_TAG"
   (	"PK_HOST_TAG" VARCHAR2(36 BYTE) NOT NULL,
	"PK_HOST" VARCHAR2(36 BYTE) NOT NULL,
	"STR_TAG" VARCHAR2(36 BYTE) NOT NULL,
	"STR_TAG_TYPE" VARCHAR2(24 BYTE) DEFAULT 'Hardware' NOT NULL,
	"B_CONSTANT" NUMBER(1,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "JOB_USAGE"
   (	"PK_JOB_USAGE" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"INT_CORE_TIME_SUCCESS" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_CORE_TIME_FAIL" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_FRAME_SUCCESS_COUNT" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_FRAME_FAIL_COUNT" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_CLOCK_TIME_FAIL" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_CLOCK_TIME_HIGH" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_CLOCK_TIME_SUCCESS" NUMBER(16,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "JOB_RESOURCE"
   (	"PK_JOB_RESOURCE" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"INT_CORES" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_MAX_RSS" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_MAX_VSS" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_MIN_CORES" NUMBER(16,0) DEFAULT 100 NOT NULL,
	"INT_MAX_CORES" NUMBER(16,0) DEFAULT 10000 NOT NULL,
	"FLOAT_TIER" NUMBER(16,2) DEFAULT 0 NOT NULL,
	"INT_PRIORITY" NUMBER(16,0) DEFAULT 1 NOT NULL,
	"INT_LOCAL_CORES" NUMBER(16,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "JOB_STAT"
   (	"PK_JOB_STAT" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"INT_WAITING_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_RUNNING_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_DEAD_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_DEPEND_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_EATEN_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_SUCCEEDED_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_CHECKPOINT_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "SUBSCRIPTION"
   (	"PK_SUBSCRIPTION" VARCHAR2(36 BYTE) NOT NULL,
	"PK_ALLOC" VARCHAR2(36 BYTE) NOT NULL,
	"PK_SHOW" VARCHAR2(36 BYTE) NOT NULL,
	"INT_SIZE" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_BURST" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_CORES" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"FLOAT_TIER" NUMBER(16,2) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "SHOW"
   (	"PK_SHOW" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(36 BYTE) NOT NULL,
	"B_PAUSED" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"INT_DEFAULT_MIN_CORES" NUMBER(16,0) DEFAULT 100 NOT NULL,
	"INT_DEFAULT_MAX_CORES" NUMBER(16,0) DEFAULT 10000 NOT NULL,
	"INT_FRAME_INSERT_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_JOB_INSERT_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_FRAME_SUCCESS_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_FRAME_FAIL_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"B_BOOKING_ENABLED" NUMBER(1,0) DEFAULT 1 NOT NULL,
	"B_DISPATCH_ENABLED" NUMBER(1,0) DEFAULT 1 NOT NULL,
	"B_ACTIVE" NUMBER(1,0) DEFAULT 1 NOT NULL,
	"STR_COMMENT_EMAIL" VARCHAR2(1024 BYTE)
   )
-- SPLIT HERE!
CREATE TABLE "PROC"
   (	"PK_PROC" VARCHAR2(36 BYTE) NOT NULL,
	"PK_HOST" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE),
	"PK_SHOW" VARCHAR2(36 BYTE),
	"PK_LAYER" VARCHAR2(36 BYTE),
	"PK_FRAME" VARCHAR2(36 BYTE),
	"INT_CORES_RESERVED" NUMBER(38,0) NOT NULL,
	"INT_MEM_RESERVED" NUMBER(38,0) NOT NULL,
	"INT_MEM_USED" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_MEM_MAX_USED" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"B_UNBOOKED" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"INT_MEM_PRE_RESERVED" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_VIRT_USED" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_VIRT_MAX_USED" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"STR_REDIRECT" VARCHAR2(265 BYTE),
	"B_LOCAL" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"TS_PING" TIMESTAMP (6) WITH TIME ZONE DEFAULT systimestamp NOT NULL,
	"TS_BOOKED" TIMESTAMP (6) WITH TIME ZONE DEFAULT systimestamp NOT NULL,
	"TS_DISPATCHED" TIMESTAMP (6) WITH TIME ZONE DEFAULT systimestamp NOT NULL,
	"INT_GPU_RESERVED" NUMBER(10,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "MATCHER"
   (	"PK_MATCHER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_FILTER" VARCHAR2(36 BYTE) NOT NULL,
	"STR_SUBJECT" VARCHAR2(64 BYTE) NOT NULL,
	"STR_MATCH" VARCHAR2(64 BYTE) NOT NULL,
	"STR_VALUE" VARCHAR2(4000 BYTE) NOT NULL,
	"TS_CREATED" TIMESTAMP (6) DEFAULT systimestamp NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "LAYER_USAGE"
   (	"PK_LAYER_USAGE" VARCHAR2(36 BYTE) NOT NULL,
	"PK_LAYER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"INT_CORE_TIME_SUCCESS" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_CORE_TIME_FAIL" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_FRAME_SUCCESS_COUNT" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_FRAME_FAIL_COUNT" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_CLOCK_TIME_FAIL" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_CLOCK_TIME_HIGH" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_CLOCK_TIME_LOW" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_CLOCK_TIME_SUCCESS" NUMBER(16,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "LAYER_STAT"
   (	"PK_LAYER_STAT" VARCHAR2(36 BYTE) NOT NULL,
	"PK_LAYER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"INT_TOTAL_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_WAITING_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_RUNNING_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_DEAD_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_DEPEND_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_EATEN_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_SUCCEEDED_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_CHECKPOINT_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "LAYER_RESOURCE"
   (	"PK_LAYER_RESOURCE" VARCHAR2(36 BYTE) NOT NULL,
	"PK_LAYER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"INT_CORES" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_MAX_RSS" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_MAX_VSS" NUMBER(16,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "LAYER_ENV"
   (	"PK_LAYER_ENV" VARCHAR2(36 BYTE) NOT NULL,
	"PK_LAYER" VARCHAR2(36 BYTE),
	"PK_JOB" VARCHAR2(36 BYTE),
	"STR_KEY" VARCHAR2(36 BYTE),
	"STR_VALUE" VARCHAR2(2048 BYTE)
   )
-- SPLIT HERE!
CREATE TABLE "LAYER"
   (	"PK_LAYER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(256 BYTE) NOT NULL,
	"STR_CMD" VARCHAR2(4000 BYTE) NOT NULL,
	"STR_RANGE" VARCHAR2(4000 BYTE) NOT NULL,
	"INT_CHUNK_SIZE" NUMBER(38,0) DEFAULT 1 NOT NULL,
	"INT_DISPATCH_ORDER" NUMBER(38,0) DEFAULT 1 NOT NULL,
	"INT_CORES_MIN" NUMBER(38,0) DEFAULT 100 NOT NULL,
	"INT_MEM_MIN" NUMBER(38,0) DEFAULT 4194304 NOT NULL,
	"STR_TAGS" VARCHAR2(4000 BYTE) DEFAULT '' NOT NULL,
	"STR_TYPE" VARCHAR2(16 BYTE) NOT NULL,
	"B_THREADABLE" NUMBER(1,0) DEFAULT 1 NOT NULL,
	"STR_SERVICES" VARCHAR2(128 BYTE) DEFAULT 'default' NOT NULL,
	"B_OPTIMIZE" NUMBER(1,0) DEFAULT 1 NOT NULL,
	"INT_CORES_MAX" NUMBER(10,0) DEFAULT 0 NOT NULL,
	"INT_GPU_MIN" NUMBER(10,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "JOB_ENV"
   (	"PK_JOB_ENV" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE),
	"STR_KEY" VARCHAR2(36 BYTE),
	"STR_VALUE" VARCHAR2(2048 BYTE)
   )
-- SPLIT HERE!
CREATE TABLE "JOB"
   (	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"PK_FOLDER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_SHOW" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(255 BYTE) NOT NULL,
	"STR_VISIBLE_NAME" VARCHAR2(255 BYTE),
	"STR_SHOT" VARCHAR2(64 BYTE) NOT NULL,
	"STR_USER" VARCHAR2(32 BYTE) NOT NULL,
	"STR_STATE" VARCHAR2(16 BYTE) NOT NULL,
	"STR_LOG_DIR" VARCHAR2(4000 BYTE) DEFAULT '' NOT NULL,
	"INT_UID" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"B_PAUSED" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"B_AUTOEAT" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"INT_FRAME_COUNT" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_LAYER_COUNT" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_MAX_RETRIES" NUMBER(4,0) DEFAULT 3 NOT NULL,
	"B_AUTO_BOOK" NUMBER(1,0) DEFAULT 1 NOT NULL,
	"B_AUTO_UNBOOK" NUMBER(1,0) DEFAULT 1 NOT NULL,
	"B_COMMENT" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"STR_EMAIL" VARCHAR2(256 BYTE),
	"PK_FACILITY" VARCHAR2(36 BYTE) NOT NULL,
	"PK_DEPT" VARCHAR2(36 BYTE) NOT NULL,
	"TS_STARTED" TIMESTAMP (6) WITH TIME ZONE DEFAULT systimestamp NOT NULL,
	"TS_STOPPED" TIMESTAMP (6) WITH TIME ZONE,
	"INT_MIN_CORES" NUMBER(16,0) DEFAULT 100 NOT NULL,
	"INT_MAX_CORES" NUMBER(16,0) DEFAULT 20000 NOT NULL,
	"STR_SHOW" VARCHAR2(32 BYTE) DEFAULT 'none' NOT NULL,
	"TS_UPDATED" TIMESTAMP (6) WITH TIME ZONE DEFAULT systimestamp NOT NULL,
	"STR_OS" VARCHAR2(12 BYTE) DEFAULT 'rhel40' NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "HOST_STAT"
   (	"PK_HOST_STAT" VARCHAR2(36 BYTE) NOT NULL,
	"PK_HOST" VARCHAR2(36 BYTE) NOT NULL,
	"INT_MEM_TOTAL" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_MEM_FREE" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_SWAP_TOTAL" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_SWAP_FREE" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_MCP_TOTAL" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_MCP_FREE" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_LOAD" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"TS_PING" TIMESTAMP (6) WITH TIME ZONE DEFAULT systimestamp NOT NULL,
	"TS_BOOTED" TIMESTAMP (6) WITH TIME ZONE DEFAULT systimestamp NOT NULL,
	"STR_STATE" VARCHAR2(32 BYTE) DEFAULT 'Up' NOT NULL,
	"STR_OS" VARCHAR2(12 BYTE) DEFAULT 'rhel40' NOT NULL,
	"INT_GPU_TOTAL" NUMBER(10,0) DEFAULT 0 NOT NULL,
	"INT_GPU_FREE" NUMBER(10,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "HOST"
   (	"PK_HOST" VARCHAR2(36 BYTE) NOT NULL,
	"PK_ALLOC" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(30 BYTE) NOT NULL,
	"STR_LOCK_STATE" VARCHAR2(36 BYTE) NOT NULL,
	"B_NIMBY" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"TS_CREATED" TIMESTAMP (6) DEFAULT systimestamp NOT NULL,
	"INT_CORES" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_PROCS" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_CORES_IDLE" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_MEM" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_MEM_IDLE" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"B_UNLOCK_BOOT" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"B_UNLOCK_IDLE" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"B_REBOOT_IDLE" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"STR_TAGS" VARCHAR2(128 BYTE),
	"STR_FQDN" VARCHAR2(128 BYTE),
	"B_COMMENT" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"INT_THREAD_MODE" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"STR_LOCK_SOURCE" VARCHAR2(128 BYTE),
	"INT_GPU" NUMBER(10,0) DEFAULT 0 NOT NULL,
	"INT_GPU_IDLE" NUMBER(10,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "FRAME"
   (	"PK_FRAME" VARCHAR2(36 BYTE) NOT NULL,
	"PK_LAYER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(256 BYTE) NOT NULL,
	"STR_STATE" VARCHAR2(24 BYTE) NOT NULL,
	"INT_NUMBER" NUMBER(38,0) NOT NULL,
	"INT_DEPEND_COUNT" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_EXIT_STATUS" NUMBER(38,0) DEFAULT -1 NOT NULL,
	"INT_RETRIES" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_MEM_RESERVED" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_MEM_MAX_USED" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_MEM_USED" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"INT_DISPATCH_ORDER" NUMBER(38,0) DEFAULT 0 NOT NULL,
	"STR_HOST" VARCHAR2(256 BYTE),
	"INT_CORES" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_LAYER_ORDER" NUMBER(16,0) NOT NULL,
	"TS_STARTED" TIMESTAMP (6) WITH TIME ZONE,
	"TS_STOPPED" TIMESTAMP (6) WITH TIME ZONE,
	"TS_LAST_RUN" TIMESTAMP (6) WITH TIME ZONE,
	"TS_UPDATED" TIMESTAMP (6) WITH TIME ZONE,
	"INT_VERSION" NUMBER(16,0) DEFAULT 0,
	"STR_CHECKPOINT_STATE" VARCHAR2(12 BYTE) DEFAULT 'Disabled' NOT NULL,
	"INT_CHECKPOINT_COUNT" NUMBER(6,0) DEFAULT 0 NOT NULL,
	"INT_GPU_RESERVED" NUMBER(10,0) DEFAULT 0 NOT NULL,
	"INT_TOTAL_PAST_CORE_TIME" NUMBER(16,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "FOLDER_LEVEL"
   (	"PK_FOLDER_LEVEL" VARCHAR2(36 BYTE) NOT NULL,
	"PK_FOLDER" VARCHAR2(36 BYTE) NOT NULL,
	"INT_LEVEL" NUMBER(38,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "FOLDER"
   (	"PK_FOLDER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_PARENT_FOLDER" VARCHAR2(36 BYTE),
	"PK_SHOW" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(36 BYTE) NOT NULL,
	"INT_PRIORITY" NUMBER(38,0) DEFAULT 1 NOT NULL,
	"B_DEFAULT" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"PK_DEPT" VARCHAR2(36 BYTE) NOT NULL,
	"INT_JOB_MIN_CORES" NUMBER(16,0) DEFAULT -1 NOT NULL,
	"INT_JOB_MAX_CORES" NUMBER(16,0) DEFAULT -1 NOT NULL,
	"INT_JOB_PRIORITY" NUMBER(16,0) DEFAULT -1 NOT NULL,
	"INT_MIN_CORES" NUMBER(16,0) DEFAULT 0 NOT NULL,
	"INT_MAX_CORES" NUMBER(16,0) DEFAULT -1 NOT NULL,
	"B_EXCLUDE_MANAGED" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"int_order" NUMBER(16,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "FILTER"
   (	"PK_FILTER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_SHOW" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(128 BYTE) NOT NULL,
	"STR_TYPE" VARCHAR2(16 BYTE) NOT NULL,
	"int_order" NUMBER(6,2) DEFAULT 0.0 NOT NULL,
	"B_ENABLED" NUMBER(1,0) DEFAULT 1 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "DEPEND"
   (	"PK_DEPEND" VARCHAR2(36 BYTE) NOT NULL,
	"PK_PARENT" VARCHAR2(36 BYTE),
	"PK_JOB_DEPEND_ON" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB_DEPEND_ER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_FRAME_DEPEND_ON" VARCHAR2(36 BYTE),
	"PK_FRAME_DEPEND_ER" VARCHAR2(36 BYTE),
	"PK_LAYER_DEPEND_ON" VARCHAR2(36 BYTE),
	"PK_LAYER_DEPEND_ER" VARCHAR2(36 BYTE),
	"STR_TYPE" VARCHAR2(36 BYTE) NOT NULL,
	"B_ACTIVE" NUMBER(1,0) DEFAULT 1 NOT NULL,
	"B_ANY" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"TS_CREATED" TIMESTAMP (6) DEFAULT systimestamp NOT NULL,
	"TS_SATISFIED" TIMESTAMP (6),
	"STR_TARGET" VARCHAR2(20 BYTE) DEFAULT 'Internal' NOT NULL,
	"STR_SIGNATURE" VARCHAR2(36 BYTE) NOT NULL,
	"B_COMPOSITE" NUMBER(1,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "CONFIG"
   (	"PK_CONFIG" VARCHAR2(36 BYTE) NOT NULL,
	"STR_KEY" VARCHAR2(36 BYTE) NOT NULL,
	"INT_VALUE" NUMBER(38,0) DEFAULT 0,
	"LONG_VALUE" NUMBER(38,0) DEFAULT 0,
	"STR_VALUE" VARCHAR2(255 BYTE) DEFAULT '',
	"B_VALUE" NUMBER(1,0) DEFAULT 0
   )
-- SPLIT HERE!
CREATE TABLE "COMMENTS"
   (	"PK_COMMENT" VARCHAR2(36 BYTE) NOT NULL,
	"PK_JOB" VARCHAR2(36 BYTE),
	"PK_HOST" VARCHAR2(36 BYTE),
	"TS_CREATED" TIMESTAMP (6) DEFAULT systimestamp NOT NULL,
	"STR_USER" VARCHAR2(36 BYTE) NOT NULL,
	"STR_SUBJECT" VARCHAR2(128 BYTE) NOT NULL,
	"STR_MESSAGE" VARCHAR2(4000 BYTE) NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "ALLOC"
   (	"PK_ALLOC" VARCHAR2(36 BYTE) NOT NULL,
	"STR_NAME" VARCHAR2(36 BYTE) NOT NULL,
	"B_ALLOW_EDIT" NUMBER(1,0) DEFAULT 1 NOT NULL,
	"B_DEFAULT" NUMBER(1,0) DEFAULT 0 NOT NULL,
	"STR_TAG" VARCHAR2(24 BYTE),
	"B_BILLABLE" NUMBER(1,0) DEFAULT 1 NOT NULL,
	"PK_FACILITY" VARCHAR2(36 BYTE) NOT NULL,
	"B_ENABLED" NUMBER(1,0) DEFAULT 1
   )
-- SPLIT HERE!
CREATE TABLE "ACTION"
   (	"PK_ACTION" VARCHAR2(36 BYTE) NOT NULL,
	"PK_FILTER" VARCHAR2(36 BYTE) NOT NULL,
	"PK_FOLDER" VARCHAR2(36 BYTE),
	"STR_ACTION" VARCHAR2(24 BYTE) NOT NULL,
	"STR_VALUE_TYPE" VARCHAR2(24 BYTE) NOT NULL,
	"STR_VALUE" VARCHAR2(4000 BYTE),
	"INT_VALUE" NUMBER(38,0),
	"B_VALUE" NUMBER(1,0),
	"TS_CREATED" TIMESTAMP (6) DEFAULT systimestamp NOT NULL,
	"FLOAT_VALUE" NUMBER(6,2),
	"B_STOP" NUMBER(1,0) DEFAULT 0 NOT NULL
   )
-- SPLIT HERE!
CREATE TABLE "REDIRECT"
   (	"PK_PROC" VARCHAR2(36 BYTE) NOT NULL,
    "STR_GROUP_ID" VARCHAR(36 BYTE) NOT NULL,
    "INT_TYPE" NUMBER(38,0) NOT NULL,
    "STR_DESTINATION_ID" VARCHAR2(512 BYTE) NOT NULL,
    "STR_NAME" VARCHAR2(512 BYTE) NOT NULL,
    "LNG_CREATION_TIME" NUMBER(38,0) NOT NULL
   )


-- SPLIT HERE!
 COMMENT ON COLUMN "JOB_HISTORY"."INT_CORE_TIME_SUCCESS" IS 'seconds per core succeeded'
-- SPLIT HERE!
 COMMENT ON COLUMN "JOB_HISTORY"."INT_CORE_TIME_FAIL" IS 'seconds per core failed'
-- SPLIT HERE!
 COMMENT ON COLUMN "JOB_HISTORY"."INT_MAX_RSS" IS 'maximum kilobytes of rss memory used by a single frame'
-- SPLIT HERE!
 COMMENT ON COLUMN "LAYER_HISTORY"."INT_CORE_TIME_SUCCESS" IS 'seconds per core succeeded'
-- SPLIT HERE!
 COMMENT ON COLUMN "LAYER_HISTORY"."INT_CORE_TIME_FAIL" IS 'seconds per core failed'
-- SPLIT HERE!
 COMMENT ON COLUMN "LAYER_HISTORY"."INT_MAX_RSS" IS 'maximum kilobytes of rss memory used by a single frame'
-- SPLIT HERE!
 COMMENT ON COLUMN "FRAME_HISTORY"."INT_MEM_RESERVED" IS 'kilobytes of memory reserved'
-- SPLIT HERE!
 COMMENT ON COLUMN "FRAME_HISTORY"."INT_MEM_MAX_USED" IS 'maximum kilobytes of rss memory used'
-- SPLIT HERE!
 COMMENT ON COLUMN "FRAME_HISTORY"."INT_CORES" IS '100 cores per physical core'

-- SPLIT HERE!
CREATE PACKAGE HISTORY AS

    procedure period_shift;
    procedure period_shift(piEndDate in date);
    procedure period_clear;

END HISTORY;
-- SPLIT HERE!
CREATE FUNCTION CALCULATE_CORE_HOURS
(int_ts_started NUMERIC, int_ts_stopped NUMERIC,
int_start_report NUMERIC, int_stop_report NUMERIC,
int_job_stopped NUMERIC, int_cores NUMBER)
RETURN NUMBER IS
  int_started NUMERIC(12,0);
  int_stopped NUMERIC(12,0);
BEGIN
    IF int_cores = 0 THEN
        RETURN 0;
    END IF;

    int_started := int_ts_started;
    int_stopped := int_ts_stopped;

    IF int_stopped = 0 THEN
        int_stopped := int_job_stopped;
    END IF;

    IF int_stopped = 0 OR int_stopped > int_stop_report THEN
        int_stopped := int_stop_report;
    END IF;

    IF int_started < int_start_report THEN
        int_started := int_start_report;
    END IF;
    RETURN ((int_stopped - int_started) * (int_cores / 100) / 3600);
END;
-- SPLIT HERE!
CREATE FUNCTION "INTERVAL_TO_SECONDS"
( intrvl IN DSINTERVAL_UNCONSTRAINED
) RETURN NUMBER AS
BEGIN
   RETURN EXTRACT(DAY FROM intrvl) * 86400
         + EXTRACT(HOUR FROM intrvl) * 3600
         + EXTRACT(MINUTE FROM intrvl) * 60
         + EXTRACT(SECOND FROM intrvl);
END INTERVAL_TO_SECONDS;
-- SPLIT HERE!
CREATE FUNCTION "EPOCH"
( t IN TIMESTAMP WITH TIME ZONE
) RETURN NUMBER AS
  epoch_date TIMESTAMP(0) WITH TIME ZONE := TIMESTAMP '1970-01-01 00:00:00.00 +00:00';
  epoch_sec NUMERIC(12,0);
  delta INTERVAL DAY(9) TO SECOND(0);
BEGIN
  delta := t - epoch_date;
  RETURN INTERVAL_TO_SECONDS(delta);
END EPOCH;
-- SPLIT HERE!
CREATE FUNCTION      epoch_to_ts(seconds IN NUMBER)
RETURN TIMESTAMP AS
BEGIN
    RETURN TO_TIMESTAMP('19700101000000','YYYYMMDDHH24MISS TZH:TZM')
        + NUMTODSINTERVAL(seconds, 'SECOND');
END;
-- SPLIT HERE!
CREATE FUNCTION FIND_DURATION
(ts_started TIMESTAMP, ts_stopped TIMESTAMP)
RETURN NUMBER IS
  t_interval INTERVAL DAY TO SECOND;
  t_stopped TIMESTAMP(0);
BEGIN

    IF ts_started IS NULL THEN
        RETURN 0;
    END IF;

    IF ts_stopped IS NULL THEN
      t_stopped := systimestamp;
    ELSE
      t_stopped := ts_stopped;
    END IF;

    t_interval := t_stopped - ts_started;

    RETURN ROUND((EXTRACT(DAY FROM t_interval) * 86400
        + EXTRACT(HOUR FROM t_interval) * 3600
        + EXTRACT(MINUTE FROM t_interval) * 60
        + EXTRACT(SECOND FROM t_interval)));
END;
-- SPLIT HERE!
CREATE FUNCTION genkey RETURN VARCHAR2 IS
    str_result VARCHAR2(36);
    guid VARCHAR2(36) := sys_guid();
BEGIN
    str_result := SUBSTR(guid, 0,8) || '-' || SUBSTR(guid,8,4)
      || '-' || SUBSTR(guid,12,4) || '-' || SUBSTR(guid,16,4) || '-' || SUBSTR(guid,20,12);
    RETURN str_result;
END;
-- SPLIT HERE!

CREATE FUNCTION render_weeks
(dt_end DATE)
RETURN NUMBER IS
    int_weeks NUMERIC;
BEGIN
    int_weeks := (dt_end - (next_day(sysdate,'sunday')+7)) / 7.0;
    IF int_weeks < 1 THEN
      RETURN 1;
    ELSE
      RETURN int_weeks;
    END IF;
END;
-- SPLIT HERE!
CREATE FUNCTION soft_tier(int_cores IN NUMERIC, int_min_cores IN NUMERIC)
RETURN NUMBER AS
BEGIN
  IF int_cores IS NULL THEN
      RETURN 0;
  END IF;
  IF int_min_cores = 0 OR int_cores >= int_min_cores THEN
      RETURN 1;
  ELSE
    IF int_cores = 0 THEN
        return int_min_cores * -1;
    ELSE
        RETURN int_cores / int_min_cores;
    END IF;
  END IF;
END;
-- SPLIT HERE!
CREATE FUNCTION tier(int_cores IN NUMERIC, int_min_cores IN NUMERIC)
RETURN NUMBER AS
BEGIN

  IF int_min_cores = 0 THEN
       RETURN (int_cores / 100) + 1;
  ELSE
    IF int_cores = 0 THEN
        return int_min_cores * -1;
    ELSE
        RETURN int_cores / int_min_cores;
    END IF;
  END IF;
END;
-- SPLIT HERE!
CREATE PROCEDURE recalculate_subs
IS
BEGIN
  /**
  * concatenates all tags in host_tag and sets host.str_tags
  **/
  UPDATE subscription SET int_cores = 0;
  for r in (select proc.pk_show, alloc.pk_alloc, sum(proc.int_cores_reserved) as c from proc, host, alloc
  where proc.pk_host = host.pk_host AND host.pk_alloc = alloc.pk_alloc
  group by proc.pk_show, alloc.pk_alloc) LOOP
      UPDATE subscription SET int_cores = r.c WHERE pk_alloc=r.pk_alloc AND pk_show=r.pk_show;

  END LOOP;
END;
-- SPLIT HERE!
CREATE PROCEDURE recalculate_tags(str_host_id IN VARCHAR2)
IS
  str_tag VARCHAR2(256) := '';
BEGIN
  /**
  * concatenates all tags in host_tag and sets host.str_tags
  **/
  FOR tag IN (SELECT str_tag FROM host_tag WHERE pk_host=str_host_id ORDER BY str_tag_type ASC, str_tag ASC) LOOP
    str_tag := str_tag || ' ' || tag.str_tag;
  END LOOP;

  EXECUTE IMMEDIATE 'UPDATE host SET str_tags=trim(:1) WHERE pk_host=:2'
    USING str_tag, str_host_id;
END;
-- SPLIT HERE!
CREATE PROCEDURE recurse_folder_parent_change(str_folder_id IN VARCHAR2, str_parent_folder_id IN VARCHAR2)
IS
  int_parent_level NUMBER(38);
BEGIN
    SELECT int_level+1 INTO
        int_parent_level
    FROM
        folder_level
    WHERE
        pk_folder = str_parent_folder_id;

    UPDATE
        folder_level
    SET
        int_level = int_parent_level
    WHERE
        pk_folder = str_folder_id;

    FOR subfolder IN (SELECT pk_folder FROM folder WHERE pk_parent_folder = str_folder_id) LOOP
        recurse_folder_parent_change(subfolder.pk_folder, str_folder_id);
    END LOOP;
END;
-- SPLIT HERE!
CREATE PROCEDURE rename_allocs
IS
BEGIN
    FOR alloc IN (SELECT alloc.pk_alloc, alloc.str_name AS aname,facility.str_name AS fname FROM alloc,facility
        WHERE alloc.pk_facility = facility.pk_facility) LOOP
        EXECUTE IMMEDIATE 'UPDATE alloc SET str_name=:1 WHERE pk_alloc=:2' USING
            alloc.fname || '.' || alloc.aname, alloc.pk_alloc;
    END LOOP;
END;
-- SPLIT HERE!
CREATE PROCEDURE reorder_filters(p_str_show_id IN VARCHAR2) IS
    f_new_order NUMBER(16,0) := 1.0;
BEGIN
    FOR r_filter IN (SELECT pk_filter FROM filter WHERE pk_show=p_str_show_id ORDER BY int_order ASC) LOOP
        UPDATE filter SET int_order=f_new_order WHERE pk_filter = r_filter.pk_filter;
        f_new_order := f_new_order + 1.0;
    END LOOP;
END;
-- SPLIT HERE!
CREATE PROCEDURE tmp_populate_folder IS
BEGIN
    FOR t in (select pk_folder, pk_show, sum(int_cores) AS c from job, job_resource where job.pk_job = job_resource.pk_job GROUP by pk_folder, pk_show) LOOP
        UPDATE folder_resource SET int_cores = t.c WHERE pk_folder = t.pk_folder;
        COMMIT;
    END LOOP;
END;
-- SPLIT HERE!
CREATE PROCEDURE tmp_populate_point IS
BEGIN
    FOR t in (select pk_dept, pk_show, sum(int_cores) AS c from job, job_resource where job.pk_job = job_resource.pk_job GROUP by pk_dept, pk_show) LOOP
        UPDATE point SET int_cores = t.c WHERE pk_show = t.pk_show AND pk_dept = t.pk_dept;
    END LOOP;
END;
-- SPLIT HERE!
CREATE PROCEDURE tmp_populate_sub IS
BEGIN
    FOR t in (select proc.pk_show, host.pk_alloc, sum(int_cores_reserved) AS c from proc,host where
        proc.pk_host = host.pk_host GROUP BY proc.pk_show, host.pk_alloc)  LOOP
        UPDATE subscription SET int_cores = t.c WHERE pk_show = t.pk_show AND pk_alloc = t.pk_alloc;
    END LOOP;
END;

-- SPLIT HERE!
CREATE UNIQUE INDEX "C_ACTION_PK" ON "ACTION" ("PK_ACTION")
-- SPLIT HERE!
CREATE INDEX "I_ACTION_PK_FILTER" ON "ACTION" ("PK_FILTER")
-- SPLIT HERE!
CREATE INDEX "I_ACTION_PK_GROUP" ON "ACTION" ("PK_FOLDER")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_ALLOC_PK" ON "ALLOC" ("PK_ALLOC")
-- SPLIT HERE!
CREATE INDEX "I_ALLOC_PK_FACILITY" ON "ALLOC" ("PK_FACILITY")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_ALLOC_NAME_UNIQ" ON "ALLOC" ("STR_NAME")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_COMMENT_PK" ON "COMMENTS" ("PK_COMMENT")
-- SPLIT HERE!
CREATE INDEX "I_COMMENT_PK_JOB" ON "COMMENTS" ("PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_COMMENT_PK_HOST" ON "COMMENTS" ("PK_HOST")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_PK_PKCONFIG" ON "CONFIG" ("PK_CONFIG")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_SHOW_UK" ON "CONFIG" ("STR_KEY")
-- SPLIT HERE!
CREATE UNIQUE INDEX "I_DEPEND_SIGNATURE" ON "DEPEND" ("STR_SIGNATURE")
-- SPLIT HERE!
CREATE INDEX "I_DEPEND_ON_LAYER" ON "DEPEND" ("PK_LAYER_DEPEND_ON")
-- SPLIT HERE!
CREATE INDEX "I_DEPEND_ER_LAYER" ON "DEPEND" ("PK_LAYER_DEPEND_ER")
-- SPLIT HERE!
CREATE INDEX "I_DEPEND_STR_TARGET" ON "DEPEND" ("STR_TARGET")
-- SPLIT HERE!
CREATE INDEX "I_DEPEND_ON_FRAME" ON "DEPEND" ("PK_FRAME_DEPEND_ON")
-- SPLIT HERE!
CREATE INDEX "I_DEPEND_STR_TYPE" ON "DEPEND" ("STR_TYPE")
-- SPLIT HERE!
CREATE INDEX "I_DEPEND_ER_FRAME" ON "DEPEND" ("PK_FRAME_DEPEND_ER")
-- SPLIT HERE!
CREATE INDEX "I_DEPEND_B_COMPOSITE" ON "DEPEND" ("B_COMPOSITE")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_DEPEND_PK" ON "DEPEND" ("PK_DEPEND")
-- SPLIT HERE!
CREATE INDEX "I_DEPEND_PKPARENT" ON "DEPEND" ("PK_PARENT")
-- SPLIT HERE!
CREATE INDEX "I_DEPEND_PK_ON_JOB" ON "DEPEND" ("PK_JOB_DEPEND_ON")
-- SPLIT HERE!
CREATE INDEX "I_DEPEND_PK_ER_JOB" ON "DEPEND" ("PK_JOB_DEPEND_ER")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_FILTER_PK" ON "FILTER" ("PK_FILTER")
-- SPLIT HERE!
CREATE INDEX "I_FILTERS_PK_SHOW" ON "FILTER" ("PK_SHOW")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_FOLDER_UK" ON "FOLDER" ("PK_PARENT_FOLDER", "STR_NAME")
-- SPLIT HERE!
CREATE INDEX "I_FOLDER_PKPARENTFOLDER" ON "FOLDER" ("PK_PARENT_FOLDER")
-- SPLIT HERE!
CREATE INDEX "I_FOLDER_PKSHOW" ON "FOLDER" ("PK_SHOW")
-- SPLIT HERE!
CREATE INDEX "I_FOLDER_STRNAME" ON "FOLDER" ("STR_NAME")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_FOLDER_PK" ON "FOLDER" ("PK_FOLDER")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_FOLDER_LEVEL_PK" ON "FOLDER_LEVEL" ("PK_FOLDER_LEVEL")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_FOLDER_LEVEL_UK" ON "FOLDER_LEVEL" ("PK_FOLDER")
-- SPLIT HERE!
CREATE INDEX "I_FRAME_STATE_JOB" ON "FRAME" ("STR_STATE", "PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_FRAME_DISPATCH_IDX" ON "FRAME" ("INT_DISPATCH_ORDER", "INT_LAYER_ORDER")
-- SPLIT HERE!
CREATE INDEX "I_FRAME_PK_JOB" ON "FRAME" ("PK_JOB")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_FRAME_PK" ON "FRAME" ("PK_FRAME")
-- SPLIT HERE!
CREATE INDEX "I_FRAME_PKJOBLAYER" ON "FRAME" ("PK_LAYER")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_FRAME_STR_NAME_UNQ" ON "FRAME" ("STR_NAME", "PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_FRAME_INT_GPU_RESERVED" ON "FRAME" ("INT_GPU_RESERVED")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_STR_HOST_FQDN_UK" ON "HOST" ("STR_FQDN")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_HOST_PK" ON "HOST" ("PK_HOST")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_HOST_UK" ON "HOST" ("STR_NAME")
-- SPLIT HERE!
CREATE INDEX "I_HOST_PKALLOC" ON "HOST" ("PK_ALLOC")
-- SPLIT HERE!
CREATE INDEX "I_HOST_STRLOCKSTATE" ON "HOST" ("STR_LOCK_STATE")
-- SPLIT HERE!
CREATE INDEX "I_HOST_INT_GPU" ON "HOST" ("INT_GPU")
-- SPLIT HERE!
CREATE INDEX "I_HOST_INT_GPU_IDLE" ON "HOST" ("INT_GPU_IDLE")
-- SPLIT HERE!
CREATE INDEX "I_HOST_STAT_INT_GPU_TOTAL" ON "HOST_STAT" ("INT_GPU_TOTAL")
-- SPLIT HERE!
CREATE INDEX "I_HOST_STAT_INT_GPU_FREE" ON "HOST_STAT" ("INT_GPU_FREE")
-- SPLIT HERE!
CREATE INDEX "I_HOST_STAT_STR_OS" ON "HOST_STAT" ("STR_OS")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_HOSTSTAT_PK" ON "HOST_STAT" ("PK_HOST_STAT")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_HOST_STAT_PK_HOST_UK" ON "HOST_STAT" ("PK_HOST")
-- SPLIT HERE!
CREATE INDEX "I_BOOKING_3" ON "JOB" ("STR_STATE", "B_PAUSED", "PK_SHOW", "PK_FACILITY")
-- SPLIT HERE!
CREATE INDEX "I_JOB_STR_OS" ON "JOB" ("STR_OS")
-- SPLIT HERE!
CREATE INDEX "I_JOB_PK_DEPT" ON "JOB" ("PK_DEPT")
-- SPLIT HERE!
CREATE INDEX "I_JOB_PK_FACILITY" ON "JOB" ("PK_FACILITY")
-- SPLIT HERE!
CREATE INDEX "I_JOB_STR_SHOT" ON "JOB" ("STR_SHOT")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_JOB_PK" ON "JOB" ("PK_JOB")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_JOB_UK" ON "JOB" ("STR_VISIBLE_NAME")
-- SPLIT HERE!
CREATE INDEX "I_JOB_PKGROUP" ON "JOB" ("PK_FOLDER")
-- SPLIT HERE!
CREATE INDEX "I_JOB_PKSHOW" ON "JOB" ("PK_SHOW")
-- SPLIT HERE!
CREATE INDEX "I_JOB_STR_NAME" ON "JOB" ("STR_NAME")
-- SPLIT HERE!
CREATE INDEX "I_JOB_STR_STATE" ON "JOB" ("STR_STATE")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_JOB_ENV_PK" ON "JOB_ENV" ("PK_JOB_ENV")
-- SPLIT HERE!
CREATE INDEX "I_JOB_ENV_PK_JOB" ON "JOB_ENV" ("PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_B_THREADABLE" ON "LAYER" ("B_THREADABLE")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_CORES_MEM" ON "LAYER" ("INT_CORES_MIN", "INT_MEM_MIN")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_CORES_MEM_THREAD" ON "LAYER" ("INT_CORES_MIN", "INT_MEM_MIN", "B_THREADABLE")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_MEM_MIN" ON "LAYER" ("INT_MEM_MIN")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_INT_DISPATCH_ORDER" ON "LAYER" ("INT_DISPATCH_ORDER")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_LAYER_PK" ON "LAYER" ("PK_LAYER")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_PKJOB" ON "LAYER" ("PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_STRNAME" ON "LAYER" ("STR_NAME")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_LAYER_STR_NAME_UNQ" ON "LAYER" ("STR_NAME", "PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_INT_GPU_MIN" ON "LAYER" ("INT_GPU_MIN")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_LAYER_ENV_PK" ON "LAYER_ENV" ("PK_LAYER_ENV")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_ENV_PK_JOB" ON "LAYER_ENV" ("PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_ENV_PK_LAYER" ON "LAYER_ENV" ("PK_LAYER")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_LAYERRESOURCE_PK" ON "LAYER_RESOURCE" ("PK_LAYER_RESOURCE")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_LAYERRESOURCE_UK" ON "LAYER_RESOURCE" ("PK_LAYER")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_RESOURCE_PK_JOB" ON "LAYER_RESOURCE" ("PK_JOB")
-- SPLIT HERE!
CREATE UNIQUE INDEX "I_LAYER_STAT_PK_LAYER" ON "LAYER_STAT" ("PK_LAYER")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_LAYERSTAT_PK" ON "LAYER_STAT" ("PK_LAYER_STAT")
-- SPLIT HERE!
CREATE INDEX "I_LAYERSTAT_PKJOB" ON "LAYER_STAT" ("PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_LAYERSTAT_INT_WAITING_COUNT" ON "LAYER_STAT" (CASE WHEN "INT_WAITING_COUNT" > 0 THEN 1 ELSE NULL END, CASE WHEN "INT_WAITING_COUNT" > 0 THEN "PK_LAYER" ELSE NULL END)
-- SPLIT HERE!
CREATE INDEX "I_LAYER_USAGE_PK_JOB" ON "LAYER_USAGE" ("PK_JOB")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_LAYER_USAGE_PK" ON "LAYER_USAGE" ("PK_LAYER_USAGE")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_LAYER_USAGE_PK_LAYER_UK" ON "LAYER_USAGE" ("PK_LAYER")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_MATCHER_PK" ON "MATCHER" ("PK_MATCHER")
-- SPLIT HERE!
CREATE INDEX "I_MATCHER_PK_FILTER" ON "MATCHER" ("PK_FILTER")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_PROC_PK" ON "PROC" ("PK_PROC")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_PROC_UK" ON "PROC" ("PK_FRAME")
-- SPLIT HERE!
CREATE INDEX "I_PROC_PKHOST" ON "PROC" ("PK_HOST")
-- SPLIT HERE!
CREATE INDEX "I_PROC_PKJOB" ON "PROC" ("PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_PROC_PKLAYER" ON "PROC" ("PK_LAYER")
-- SPLIT HERE!
CREATE INDEX "I_PROC_PKSHOW" ON "PROC" ("PK_SHOW")
-- SPLIT HERE!
CREATE INDEX "I_PROC_INT_GPU_RESERVED" ON "PROC" ("INT_GPU_RESERVED")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_SHOW_PK" ON "SHOW" ("PK_SHOW")
-- SPLIT HERE!
CREATE INDEX "I_SUB_TIER" ON "SUBSCRIPTION" ("FLOAT_TIER")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_SUBSCRIPTION_PK" ON "SUBSCRIPTION" ("PK_SUBSCRIPTION")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_SUBSCRIPTION_UK" ON "SUBSCRIPTION" ("PK_SHOW", "PK_ALLOC")
-- SPLIT HERE!
CREATE INDEX "I_SUBSCRIPTION_PKALLOC" ON "SUBSCRIPTION" ("PK_ALLOC")
-- SPLIT HERE!
CREATE INDEX "I_JOB_STAT_INT_WAITING_COUNT" ON "JOB_STAT" ("INT_WAITING_COUNT")
-- SPLIT HERE!
CREATE UNIQUE INDEX "I_JOB_STAT_PK_JOB" ON "JOB_STAT" ("PK_JOB")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_JOB_STAT_PK" ON "JOB_STAT" ("PK_JOB_STAT")
-- SPLIT HERE!
CREATE INDEX "I_JOB_RESOURCE_MIN_MAX" ON "JOB_RESOURCE" ("INT_MIN_CORES", "INT_MAX_CORES")
-- SPLIT HERE!
CREATE INDEX "I_JOB_TIER" ON "JOB_RESOURCE" ("FLOAT_TIER")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_JOB_RESOURCE_PK" ON "JOB_RESOURCE" ("PK_JOB_RESOURCE")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_JOB_RESOURCE_UK" ON "JOB_RESOURCE" ("PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_JOB_RESOURCE_CORES" ON "JOB_RESOURCE" ("INT_CORES")
-- SPLIT HERE!
CREATE INDEX "I_JOB_RESOURCE_MAX_C" ON "JOB_RESOURCE" ("INT_MAX_CORES")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_JOB_USAGE_PK" ON "JOB_USAGE" ("PK_JOB_USAGE")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_JOB_USAGE_PK_JOB_UNIQ" ON "JOB_USAGE" ("PK_JOB")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_HOST_TAG_PK" ON "HOST_TAG" ("PK_HOST_TAG")
-- SPLIT HERE!
CREATE INDEX "I_HOST_TAG_PK_HOST" ON "HOST_TAG" ("PK_HOST")
-- SPLIT HERE!
CREATE INDEX "I_HOST_STR_TAG_TYPE" ON "HOST_TAG" ("STR_TAG_TYPE")
-- SPLIT HERE!
CREATE INDEX "MATTHEW_STATS_TAB" ON "MATTHEW_STATS_TAB" ("STATID", "TYPE", "C5", "C1", "C2", "C3", "C4", "VERSION")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_TASK_LOCK_PK" ON "TASK_LOCK" ("PK_TASK_LOCK")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_JOB_HISTORY_PK" ON "JOB_HISTORY" ("PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_JOB_HISTORY_PK_SHOW" ON "JOB_HISTORY" ("PK_SHOW")
-- SPLIT HERE!
CREATE INDEX "I_JOB_HISTORY_B_ARCHIVED" ON "JOB_HISTORY" ("B_ARCHIVED")
-- SPLIT HERE!
CREATE INDEX "I_JOB_HISTORY_TS_START_STOP" ON "JOB_HISTORY" ("INT_TS_STARTED", "INT_TS_STOPPED")
-- SPLIT HERE!
CREATE INDEX "I_JOB_HISTORY_STR_NAME" ON "JOB_HISTORY" ("STR_NAME")
-- SPLIT HERE!
CREATE INDEX "I_JOB_HISTORY_STR_SHOT" ON "JOB_HISTORY" ("STR_SHOT")
-- SPLIT HERE!
CREATE INDEX "I_JOB_HISTORY_STR_USER" ON "JOB_HISTORY" ("STR_USER")
-- SPLIT HERE!
CREATE INDEX "I_JOB_HISTORY_PK_DEPT" ON "JOB_HISTORY" ("PK_DEPT")
-- SPLIT HERE!
CREATE INDEX "I_JOB_HISTORY_PK_FACILITY" ON "JOB_HISTORY" ("PK_FACILITY")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_LAYER_HISTORY_PK" ON "LAYER_HISTORY" ("PK_LAYER")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_HISTORY_STR_NAME" ON "LAYER_HISTORY" ("STR_NAME")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_HISTORY_STR_TYPE" ON "LAYER_HISTORY" ("STR_TYPE")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_HISTORY_PK_JOB" ON "LAYER_HISTORY" ("PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_HISTORY_B_ARCHIVED" ON "LAYER_HISTORY" ("B_ARCHIVED")
-- SPLIT HERE!
CREATE INDEX "I_JOB_POST_PK_POST_JOB" ON "JOB_POST" ("PK_POST_JOB")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_JOB_POST_PK" ON "JOB_POST" ("PK_JOB_POST")
-- SPLIT HERE!
CREATE INDEX "I_JOB_POST_PK_JOB" ON "JOB_POST" ("PK_JOB")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_FACILITY_PK" ON "FACILITY" ("PK_FACILITY")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_DEPT_PK" ON "DEPT" ("PK_DEPT")
-- SPLIT HERE!
CREATE INDEX "I_SHOW_ALIAS_PK_SHOW" ON "SHOW_ALIAS" ("PK_SHOW")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_SHOW_ALIAS_PK" ON "SHOW_ALIAS" ("PK_SHOW_ALIAS")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_FOLDER_RESOURCE_PK" ON "FOLDER_RESOURCE" ("PK_FOLDER_RESOURCE")
-- SPLIT HERE!
CREATE INDEX "I_FOLDER_RES_INT_MAX_CORES" ON "FOLDER_RESOURCE" ("INT_MAX_CORES")
-- SPLIT HERE!
CREATE INDEX "I_FOLDER_RESOURCE_FL_TIER" ON "FOLDER_RESOURCE" ("FLOAT_TIER")
-- SPLIT HERE!
CREATE INDEX "I_FOLDERRESOURCE_PKFOLDER" ON "FOLDER_RESOURCE" ("PK_FOLDER")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_JOB_MEM_PK" ON "JOB_MEM" ("PK_JOB_MEM")
-- SPLIT HERE!
CREATE UNIQUE INDEX "I_JOB_MEM_PK_JOB" ON "JOB_MEM" ("PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_JOB_MEM_INT_MAX_RSS" ON "JOB_MEM" ("INT_MAX_RSS")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_LAYER_MEM_PK" ON "LAYER_MEM" ("PK_LAYER_MEM")
-- SPLIT HERE!
CREATE UNIQUE INDEX "I_LAYER_MEM_PK_LAYER" ON "LAYER_MEM" ("PK_LAYER")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_MEM_PK_JOB" ON "LAYER_MEM" ("PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_MEM_INT_MAX_RSS" ON "LAYER_MEM" ("INT_MAX_RSS")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_POINT_PK" ON "POINT" ("PK_POINT")
-- SPLIT HERE!
CREATE INDEX "I_POINT_PK_DEPT" ON "POINT" ("PK_DEPT")
-- SPLIT HERE!
CREATE INDEX "I_POINT_PK_SHOW" ON "POINT" ("PK_SHOW")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_POINT_PK_SHOW_DEPT" ON "POINT" ("PK_SHOW", "PK_DEPT")
-- SPLIT HERE!
CREATE INDEX "I_POINT_TIER" ON "POINT" ("FLOAT_TIER")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_TASK_PK" ON "TASK" ("PK_TASK")
-- SPLIT HERE!
CREATE INDEX "I_TASK_PK_POINT" ON "TASK" ("PK_POINT")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_TASK_UNIQ" ON "TASK" ("STR_SHOT", "PK_POINT")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_PK_JOB_LOCAL" ON "JOB_LOCAL" ("PK_JOB_LOCAL")
-- SPLIT HERE!
CREATE UNIQUE INDEX "I_JOB_LOCAL_PK_JOB" ON "JOB_LOCAL" ("PK_JOB")
-- SPLIT HERE!
CREATE UNIQUE INDEX "I_JOB_LOCAL_PK_HOST" ON "JOB_LOCAL" ("PK_HOST")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_PK_SERVICE" ON "SERVICE" ("PK_SERVICE")
-- SPLIT HERE!
CREATE UNIQUE INDEX "I_SERVICE_STR_NAME" ON "SERVICE" ("STR_NAME")
-- SPLIT HERE!
CREATE INDEX "I_SERVICE_INT_GPU_MIN" ON "SERVICE" ("INT_GPU_MIN")
-- SPLIT HERE!
CREATE INDEX "I_HOST_LOCAL" ON "HOST_LOCAL" ("PK_HOST")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_PK_HOST_LOCAL" ON "HOST_LOCAL" ("PK_HOST_LOCAL")
-- SPLIT HERE!
CREATE INDEX "I_HOST_LOCAL_PK_JOB" ON "HOST_LOCAL" ("PK_JOB")
-- SPLIT HERE!
CREATE UNIQUE INDEX "I_HOST_LOCAL_UNIQUE" ON "HOST_LOCAL" ("PK_HOST", "PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_HOST_LOCAL_INT_GPU_IDLE" ON "HOST_LOCAL" ("INT_GPU_IDLE")
-- SPLIT HERE!
CREATE INDEX "I_HOST_LOCAL_INT_GPU_MAX" ON "HOST_LOCAL" ("INT_GPU_MAX")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_PK_OWNER" ON "OWNER" ("PK_OWNER")
-- SPLIT HERE!
CREATE INDEX "I_OWNER_PK_SHOW" ON "OWNER" ("PK_SHOW")
-- SPLIT HERE!
CREATE UNIQUE INDEX "I_OWNER_STR_USERNAME" ON "OWNER" ("STR_USERNAME")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_PK_DEED" ON "DEED" ("PK_DEED")
-- SPLIT HERE!
CREATE UNIQUE INDEX "I_DEED_PK_HOST" ON "DEED" ("PK_HOST")
-- SPLIT HERE!
CREATE INDEX "I_DEED_PK_OWNER" ON "DEED" ("PK_OWNER")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_PK_SHOW_SERVICE" ON "SHOW_SERVICE" ("PK_SHOW_SERVICE")
-- SPLIT HERE!
CREATE UNIQUE INDEX "I_SHOW_SERVICE_STR_NAME" ON "SHOW_SERVICE" ("STR_NAME", "PK_SHOW")
-- SPLIT HERE!
CREATE INDEX "I_SHOW_SERVICE_INT_GPU_MIN" ON "SHOW_SERVICE" ("INT_GPU_MIN")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_PK_LAYER_OUTPUT" ON "LAYER_OUTPUT" ("PK_LAYER_OUTPUT")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_OUTPUT_PK_LAYER" ON "LAYER_OUTPUT" ("PK_LAYER")
-- SPLIT HERE!
CREATE INDEX "I_LAYER_OUTPUT_PK_JOB" ON "LAYER_OUTPUT" ("PK_JOB")
-- SPLIT HERE!
CREATE UNIQUE INDEX "I_LAYER_OUTPUT_UNIQUE" ON "LAYER_OUTPUT" ("PK_LAYER", "STR_FILESPEC")
-- SPLIT HERE!

CREATE INDEX "I_FRAME_HISTORY_TS_START_STOP" ON "FRAME_HISTORY" ("INT_TS_STARTED", "INT_TS_STOPPED")
-- SPLIT HERE!

CREATE INDEX "I_FRAME_HISTORY_INT_EXIT_STAT" ON "FRAME_HISTORY" ("INT_EXIT_STATUS")
-- SPLIT HERE!
CREATE INDEX "I_FRAME_HISTORY_INT_TS_STOPPED" ON "FRAME_HISTORY" ("INT_TS_STOPPED")
-- SPLIT HERE!
CREATE INDEX "I_FRAME_HISTORY_PK_ALLOC" ON "FRAME_HISTORY" ("PK_ALLOC")
-- SPLIT HERE!
CREATE INDEX "I_FRAME_HISTORY_PK_FRAME" ON "FRAME_HISTORY" ("PK_FRAME")
-- SPLIT HERE!
CREATE INDEX "I_FRAME_HISTORY_PK_JOB" ON "FRAME_HISTORY" ("PK_JOB")
-- SPLIT HERE!
CREATE INDEX "I_FRAME_HISTORY_PK_LAYER" ON "FRAME_HISTORY" ("PK_LAYER")
-- SPLIT HERE!
CREATE INDEX "I_FRAME_HISTORY_STR_STATE" ON "FRAME_HISTORY" ("STR_STATE")
-- SPLIT HERE!
CREATE UNIQUE INDEX "C_REDIRECT_PK" ON "REDIRECT" ("PK_PROC")
-- SPLIT HERE!
CREATE INDEX "I_REDIRECT_GROUP" ON "REDIRECT" ("STR_GROUP_ID")
-- SPLIT HERE!
CREATE INDEX "I_REDIRECT_CREATE" ON "REDIRECT" ("LNG_CREATION_TIME")
-- SPLIT HERE!

ALTER TABLE "ACTION" ADD CONSTRAINT "C_ACTION_PK" PRIMARY KEY ("PK_ACTION")
  USING INDEX "C_ACTION_PK"
-- SPLIT HERE!
ALTER TABLE "ALLOC" ADD CONSTRAINT "C_ALLOC_NAME_UNIQ" UNIQUE ("STR_NAME")
  USING INDEX "C_ALLOC_NAME_UNIQ"
-- SPLIT HERE!
ALTER TABLE "ALLOC" ADD CONSTRAINT "C_ALLOC_PK" PRIMARY KEY ("PK_ALLOC")
  USING INDEX "C_ALLOC_PK"
-- SPLIT HERE!
ALTER TABLE "COMMENTS" ADD CONSTRAINT "C_COMMENT_PK" PRIMARY KEY ("PK_COMMENT")
  USING INDEX "C_COMMENT_PK"
-- SPLIT HERE!
ALTER TABLE "CONFIG" ADD CONSTRAINT "C_PK_PKCONFIG" PRIMARY KEY ("PK_CONFIG")
  USING INDEX "C_PK_PKCONFIG"
-- SPLIT HERE!
ALTER TABLE "CONFIG" ADD CONSTRAINT "C_SHOW_UK" UNIQUE ("STR_KEY")
  USING INDEX "C_SHOW_UK"
-- SPLIT HERE!
ALTER TABLE "DEPEND" ADD CONSTRAINT "C_DEPEND_PK" PRIMARY KEY ("PK_DEPEND")
  USING INDEX "C_DEPEND_PK"
-- SPLIT HERE!
ALTER TABLE "FILTER" ADD CONSTRAINT "C_FILTER_PK" PRIMARY KEY ("PK_FILTER")
  USING INDEX "C_FILTER_PK"
-- SPLIT HERE!
ALTER TABLE "FOLDER" ADD CONSTRAINT "C_FOLDER_UK" UNIQUE ("PK_PARENT_FOLDER", "STR_NAME")
  USING INDEX "C_FOLDER_UK"
-- SPLIT HERE!
ALTER TABLE "FOLDER" ADD CONSTRAINT "C_FOLDER_PK" PRIMARY KEY ("PK_FOLDER")
  USING INDEX "C_FOLDER_PK"
-- SPLIT HERE!
ALTER TABLE "FOLDER_LEVEL" ADD CONSTRAINT "C_FOLDER_LEVEL_PK" PRIMARY KEY ("PK_FOLDER_LEVEL")
  USING INDEX "C_FOLDER_LEVEL_PK"
-- SPLIT HERE!
ALTER TABLE "FOLDER_LEVEL" ADD CONSTRAINT "C_FOLDER_LEVEL_UK" UNIQUE ("PK_FOLDER")
  USING INDEX "C_FOLDER_LEVEL_UK"
-- SPLIT HERE!
ALTER TABLE "FRAME" ADD CONSTRAINT "C_FRAME_PK" PRIMARY KEY ("PK_FRAME")
  USING INDEX "C_FRAME_PK"
-- SPLIT HERE!
ALTER TABLE "FRAME" ADD CONSTRAINT "C_FRAME_STR_NAME_UNQ" UNIQUE ("STR_NAME", "PK_JOB")
  USING INDEX "C_FRAME_STR_NAME_UNQ"
-- SPLIT HERE!
ALTER TABLE "HOST" ADD CONSTRAINT "C_STR_HOST_FQDN_UK" UNIQUE ("STR_FQDN")
  USING INDEX "C_STR_HOST_FQDN_UK"
-- SPLIT HERE!
ALTER TABLE "HOST" ADD CONSTRAINT "C_HOST_PK" PRIMARY KEY ("PK_HOST")
  USING INDEX "C_HOST_PK"
-- SPLIT HERE!
ALTER TABLE "HOST" ADD CONSTRAINT "C_HOST_UK" UNIQUE ("STR_NAME")
  USING INDEX "C_HOST_UK"
-- SPLIT HERE!
ALTER TABLE "HOST_STAT" ADD CONSTRAINT "C_HOSTSTAT_PK" PRIMARY KEY ("PK_HOST_STAT")
  USING INDEX "C_HOSTSTAT_PK"
-- SPLIT HERE!
ALTER TABLE "HOST_STAT" ADD CONSTRAINT "C_HOST_STAT_PK_HOST_UK" UNIQUE ("PK_HOST")
  USING INDEX "C_HOST_STAT_PK_HOST_UK"
-- SPLIT HERE!
ALTER TABLE "JOB" ADD CONSTRAINT "C_JOB_PK" PRIMARY KEY ("PK_JOB")
  USING INDEX "C_JOB_PK"
-- SPLIT HERE!
ALTER TABLE "JOB" ADD CONSTRAINT "C_JOB_UK" UNIQUE ("STR_VISIBLE_NAME")
  USING INDEX "C_JOB_UK"
-- SPLIT HERE!
ALTER TABLE "JOB_ENV" ADD CONSTRAINT "C_JOB_ENV_PK" PRIMARY KEY ("PK_JOB_ENV")
  USING INDEX "C_JOB_ENV_PK"
-- SPLIT HERE!
ALTER TABLE "JOB_LOCAL" ADD CONSTRAINT "C_PK_JOB_LOCAL" PRIMARY KEY ("PK_JOB_LOCAL")
  USING INDEX "C_PK_JOB_LOCAL"
-- SPLIT HERE!
ALTER TABLE "SERVICE" ADD CONSTRAINT "C_PK_SERVICE" PRIMARY KEY ("PK_SERVICE")
  USING INDEX "C_PK_SERVICE"
-- SPLIT HERE!
ALTER TABLE "HOST_LOCAL" ADD CONSTRAINT "C_PK_HOST_LOCAL" PRIMARY KEY ("PK_HOST_LOCAL")
  USING INDEX "C_PK_HOST_LOCAL"
-- SPLIT HERE!
ALTER TABLE "OWNER" ADD CONSTRAINT "C_PK_OWNER" PRIMARY KEY ("PK_OWNER")
  USING INDEX "C_PK_OWNER"
-- SPLIT HERE!
ALTER TABLE "DEED" ADD CONSTRAINT "C_PK_DEED" PRIMARY KEY ("PK_DEED")
  USING INDEX "C_PK_DEED"
-- SPLIT HERE!
ALTER TABLE "SHOW_SERVICE" ADD CONSTRAINT "C_PK_SHOW_SERVICE" PRIMARY KEY ("PK_SHOW_SERVICE")
  USING INDEX "C_PK_SHOW_SERVICE"
-- SPLIT HERE!
ALTER TABLE "LAYER_OUTPUT" ADD CONSTRAINT "C_PK_LAYER_OUTPUT" PRIMARY KEY ("PK_LAYER_OUTPUT")
  USING INDEX "C_PK_LAYER_OUTPUT"
-- SPLIT HERE!
ALTER TABLE "LAYER" ADD CONSTRAINT "C_LAYER_PK" PRIMARY KEY ("PK_LAYER")
  USING INDEX "C_LAYER_PK"
-- SPLIT HERE!
ALTER TABLE "LAYER" ADD CONSTRAINT "C_LAYER_STR_NAME_UNQ" UNIQUE ("STR_NAME", "PK_JOB")
  USING INDEX "C_LAYER_STR_NAME_UNQ"
-- SPLIT HERE!
ALTER TABLE "LAYER_ENV" ADD CONSTRAINT "C_LAYER_ENV_PK" PRIMARY KEY ("PK_LAYER_ENV")
  USING INDEX "C_LAYER_ENV_PK"
-- SPLIT HERE!
ALTER TABLE "LAYER_RESOURCE" ADD CONSTRAINT "C_LAYERRESOURCE_PK" PRIMARY KEY ("PK_LAYER_RESOURCE")
  USING INDEX "C_LAYERRESOURCE_PK"
-- SPLIT HERE!
ALTER TABLE "LAYER_RESOURCE" ADD CONSTRAINT "C_LAYERRESOURCE_UK" UNIQUE ("PK_LAYER")
  USING INDEX "C_LAYERRESOURCE_UK"
-- SPLIT HERE!
ALTER TABLE "LAYER_STAT" ADD CONSTRAINT "C_LAYERSTAT_PK" PRIMARY KEY ("PK_LAYER_STAT")
  USING INDEX "C_LAYERSTAT_PK"
-- SPLIT HERE!
ALTER TABLE "LAYER_USAGE" ADD CONSTRAINT "C_LAYER_USAGE_PK" PRIMARY KEY ("PK_LAYER_USAGE")
  USING INDEX "C_LAYER_USAGE_PK"
-- SPLIT HERE!
ALTER TABLE "LAYER_USAGE" ADD CONSTRAINT "C_LAYER_USAGE_PK_LAYER_UK" UNIQUE ("PK_LAYER")
  USING INDEX "C_LAYER_USAGE_PK_LAYER_UK"
-- SPLIT HERE!
ALTER TABLE "MATCHER" ADD CONSTRAINT "C_MATCHER_PK" PRIMARY KEY ("PK_MATCHER")
  USING INDEX "C_MATCHER_PK"
-- SPLIT HERE!
ALTER TABLE "PROC" ADD CONSTRAINT "C_PROC_PK" PRIMARY KEY ("PK_PROC")
  USING INDEX "C_PROC_PK"
-- SPLIT HERE!
ALTER TABLE "PROC" ADD CONSTRAINT "C_PROC_UK" UNIQUE ("PK_FRAME")
  USING INDEX "C_PROC_UK"
-- SPLIT HERE!
ALTER TABLE "SHOW" ADD CONSTRAINT "C_SHOW_PK" PRIMARY KEY ("PK_SHOW")
  USING INDEX "C_SHOW_PK"
-- SPLIT HERE!
ALTER TABLE "SUBSCRIPTION" ADD CONSTRAINT "C_SUBSCRIPTION_PK" PRIMARY KEY ("PK_SUBSCRIPTION")
  USING INDEX "C_SUBSCRIPTION_PK"
-- SPLIT HERE!
ALTER TABLE "SUBSCRIPTION" ADD CONSTRAINT "C_SUBSCRIPTION_UK" UNIQUE ("PK_SHOW", "PK_ALLOC")
  USING INDEX "C_SUBSCRIPTION_UK"
-- SPLIT HERE!
ALTER TABLE "JOB_STAT" ADD CONSTRAINT "C_JOB_STAT_PK" PRIMARY KEY ("PK_JOB_STAT")
  USING INDEX "C_JOB_STAT_PK"
-- SPLIT HERE!
ALTER TABLE "JOB_RESOURCE" ADD CONSTRAINT "C_JOB_RESOURCE_PK" PRIMARY KEY ("PK_JOB_RESOURCE")
  USING INDEX "C_JOB_RESOURCE_PK"
-- SPLIT HERE!
ALTER TABLE "JOB_RESOURCE" ADD CONSTRAINT "C_JOB_RESOURCE_UK" UNIQUE ("PK_JOB")
  USING INDEX "C_JOB_RESOURCE_UK"
-- SPLIT HERE!
ALTER TABLE "JOB_USAGE" ADD CONSTRAINT "C_JOB_USAGE_PK" PRIMARY KEY ("PK_JOB_USAGE")
  USING INDEX "C_JOB_USAGE_PK"
-- SPLIT HERE!
ALTER TABLE "JOB_USAGE" ADD CONSTRAINT "C_JOB_USAGE_PK_JOB_UNIQ" UNIQUE ("PK_JOB")
  USING INDEX "C_JOB_USAGE_PK_JOB_UNIQ"
-- SPLIT HERE!
ALTER TABLE "HOST_TAG" ADD CONSTRAINT "C_HOST_TAG_PK" PRIMARY KEY ("PK_HOST_TAG")
  USING INDEX "C_HOST_TAG_PK"
-- SPLIT HERE!
ALTER TABLE "TASK_LOCK" ADD CONSTRAINT "C_TASK_LOCK_PK" PRIMARY KEY ("PK_TASK_LOCK")
  USING INDEX "C_TASK_LOCK_PK"
-- SPLIT HERE!
ALTER TABLE "JOB_HISTORY" ADD CONSTRAINT "C_JOB_HISTORY_PK" PRIMARY KEY ("PK_JOB")
  USING INDEX "C_JOB_HISTORY_PK"
-- SPLIT HERE!
ALTER TABLE "LAYER_HISTORY" ADD CONSTRAINT "C_LAYER_HISTORY_PK" PRIMARY KEY ("PK_LAYER")
  USING INDEX "C_LAYER_HISTORY_PK"
-- SPLIT HERE!
ALTER TABLE "JOB_POST" ADD CONSTRAINT "C_JOB_POST_PK" PRIMARY KEY ("PK_JOB_POST")
  USING INDEX "C_JOB_POST_PK"
-- SPLIT HERE!
ALTER TABLE "FACILITY" ADD CONSTRAINT "C_FACILITY_PK" PRIMARY KEY ("PK_FACILITY")
  USING INDEX "C_FACILITY_PK"
-- SPLIT HERE!
ALTER TABLE "DEPT" ADD CONSTRAINT "C_DEPT_PK" PRIMARY KEY ("PK_DEPT")
  USING INDEX "C_DEPT_PK"
-- SPLIT HERE!
ALTER TABLE "SHOW_ALIAS" ADD CONSTRAINT "C_SHOW_ALIAS_PK" PRIMARY KEY ("PK_SHOW_ALIAS")
  USING INDEX "C_SHOW_ALIAS_PK"
-- SPLIT HERE!
ALTER TABLE "FOLDER_RESOURCE" ADD CONSTRAINT "C_FOLDER_RESOURCE_PK" PRIMARY KEY ("PK_FOLDER_RESOURCE")
  USING INDEX "C_FOLDER_RESOURCE_PK"
-- SPLIT HERE!
ALTER TABLE "JOB_MEM" ADD CONSTRAINT "C_JOB_MEM_PK" PRIMARY KEY ("PK_JOB_MEM")
  USING INDEX "C_JOB_MEM_PK"
-- SPLIT HERE!
ALTER TABLE "LAYER_MEM" ADD CONSTRAINT "C_LAYER_MEM_PK" PRIMARY KEY ("PK_LAYER_MEM")
  USING INDEX "C_LAYER_MEM_PK"
-- SPLIT HERE!
ALTER TABLE "POINT" ADD CONSTRAINT "C_POINT_PK" PRIMARY KEY ("PK_POINT")
  USING INDEX "C_POINT_PK"
-- SPLIT HERE!
ALTER TABLE "POINT" ADD CONSTRAINT "C_POINT_PK_SHOW_DEPT" UNIQUE ("PK_SHOW", "PK_DEPT")
  USING INDEX "C_POINT_PK_SHOW_DEPT"
-- SPLIT HERE!
ALTER TABLE "TASK" ADD CONSTRAINT "C_TASK_PK" PRIMARY KEY ("PK_TASK")
  USING INDEX "C_TASK_PK"
-- SPLIT HERE!
ALTER TABLE "TASK" ADD CONSTRAINT "C_TASK_UNIQ" UNIQUE ("STR_SHOT", "PK_POINT")
  USING INDEX "C_TASK_UNIQ"
-- SPLIT HERE!
ALTER TABLE "HISTORY_PERIOD" ADD CONSTRAINT "C_HISTORY_PERIOD_PK" PRIMARY KEY ("PK")
  USING INDEX (CREATE UNIQUE INDEX "C_HISTORY_PERIOD_PK" ON "HISTORY_PERIOD" ("PK"))
-- SPLIT HERE!
ALTER TABLE "FRAME_HISTORY" ADD CONSTRAINT "C_FRAME_HISTORY_PK" PRIMARY KEY ("PK_FRAME_HISTORY")
  USING INDEX (CREATE UNIQUE INDEX "C_FRAME_HISTORY_PK" ON "FRAME_HISTORY" ("PK_FRAME_HISTORY"))
-- SPLIT HERE!
ALTER TABLE "REDIRECT" ADD CONSTRAINT "C_REDIRECT_PK" PRIMARY KEY ("PK_PROC")
  USING INDEX "C_REDIRECT_PK"
-- SPLIT HERE!

CREATE VIEW "VS_SHOW_RESOURCE" ("PK_SHOW", "INT_CORES") AS
  SELECT
        job.pk_show,
        SUM(int_cores) AS int_cores
    FROM
       job,
       job_resource
    WHERE
       job.pk_job = job_resource.pk_job
    AND
       job.str_state='Pending'
    GROUP BY
       job.pk_show

-- SPLIT HERE!
CREATE VIEW "VS_SHOW_STAT" ("PK_SHOW", "INT_PENDING_COUNT", "INT_RUNNING_COUNT", "INT_DEAD_COUNT", "INT_JOB_COUNT") AS
  SELECT
        job.pk_show,
        SUM(int_waiting_count+int_depend_count) AS int_pending_count,
        SUM(int_running_count) AS int_running_count,
        SUM(int_dead_count) AS int_dead_count,
        COUNT(1) AS int_job_count
    FROM
        job_stat,
        job
    WHERE
        job_stat.pk_job = job.pk_job
    AND
        job.str_state = 'Pending'
    GROUP BY job.pk_show

-- SPLIT HERE!
CREATE VIEW "VS_JOB_RESOURCE" ("PK_JOB", "INT_PROCS", "INT_CORES", "INT_MEM_RESERVED") AS
  SELECT
       job.pk_job,
       COUNT(proc.pk_proc) AS int_procs,
       COALESCE(SUM(int_cores_reserved),0) AS int_cores,
       COALESCE(SUM(int_mem_reserved),0) AS int_mem_reserved
    FROM
       job LEFT JOIN proc ON (proc.pk_job = job.pk_job)
    GROUP BY
       job.pk_job

-- SPLIT HERE!
CREATE VIEW "VS_ALLOC_USAGE" ("PK_ALLOC", "INT_CORES", "INT_IDLE_CORES", "INT_RUNNING_CORES", "INT_LOCKED_CORES", "INT_AVAILABLE_CORES", "INT_HOSTS", "INT_LOCKED_HOSTS", "INT_DOWN_HOSTS") AS
  SELECT
        alloc.pk_alloc,
        NVL(SUM(host.int_cores),0) AS int_cores,
        NVL(SUM(host.int_cores_idle),0) AS int_idle_cores,
        NVL(SUM(host.int_cores - host.int_cores_idle),0) as int_running_cores,
        NVL((SELECT SUM(int_cores) FROM host WHERE host.pk_alloc=alloc.pk_alloc AND (str_lock_state='NimbyLocked' OR str_lock_state='Locked')),0) AS int_locked_cores,
        NVL((SELECT SUM(int_cores_idle) FROM host h,host_stat hs WHERE h.pk_host = hs.pk_host AND h.pk_alloc=alloc.pk_alloc AND h.str_lock_state='Open' AND hs.str_state ='Up'),0) AS int_available_cores,
        COUNT(host.pk_host) AS int_hosts,
        (SELECT COUNT(*) FROM host WHERE host.pk_alloc=alloc.pk_alloc AND str_lock_state='Locked') AS int_locked_hosts,
        (SELECT COUNT(*) FROM host h,host_stat hs WHERE h.pk_host = hs.pk_host AND h.pk_alloc=alloc.pk_alloc AND hs.str_state='Down') AS int_down_hosts
    FROM
        alloc LEFT JOIN host ON (alloc.pk_alloc = host.pk_alloc)
    GROUP BY
        alloc.pk_alloc

-- SPLIT HERE!
CREATE VIEW "VS_FOLDER_COUNTS" ("PK_FOLDER", "INT_DEPEND_COUNT", "INT_WAITING_COUNT", "INT_RUNNING_COUNT", "INT_DEAD_COUNT", "INT_CORES", "INT_JOB_COUNT") AS
  SELECT
    folder.pk_folder,
    NVL(SUM(int_depend_count),0) AS int_depend_count,
    NVL(SUM(int_waiting_count),0) AS int_waiting_count,
    NVL(SUM(int_running_count),0) AS int_running_count,
    NVL(SUM(int_dead_count),0) AS int_dead_count,
    NVL(SUM(int_cores),0) AS int_cores,
    NVL(COUNT(job.pk_job),0) AS int_job_count
FROM
    folder
      LEFT JOIN
        job ON (folder.pk_folder = job.pk_folder AND job.str_state='Pending')
      LEFT JOIN
        job_stat ON (job.pk_job = job_stat.pk_job)
      LEFT JOIN
        job_resource ON (job.pk_job = job_resource.pk_job)
 GROUP BY
      folder.pk_folder

-- SPLIT HERE!
CREATE VIEW "VS_WAITING" ("PK_SHOW") AS
  SELECT
        job.pk_show
    FROM
        job_resource jr,
        job_stat,
        job
    WHERE
        job_stat.pk_job = job.pk_job
    AND
        jr.pk_job = job.pk_job
    AND
        job.str_state = 'Pending'
    AND
        job.b_paused = 0
    AND
        jr.int_max_cores - jr.int_cores >= 100
    AND
        job_stat.int_waiting_count != 0

    GROUP BY job.pk_show

-- SPLIT HERE!
CREATE VIEW "V_HISTORY_FRAME" ("PK_FRAME_HISTORY", "PK_FRAME", "PK_LAYER", "PK_JOB", "STR_NAME", "STR_STATE", "INT_MEM_RESERVED", "INT_MEM_MAX_USED", "INT_CORES", "STR_HOST", "INT_EXIT_STATUS", "STR_ALLOC_NAME", "B_ALLOC_BILLABLE", "STR_FACILITY_NAME", "INT_TS_STARTED", "INT_TS_STOPPED", "INT_CHECKPOINT_COUNT", "STR_SHOW_NAME", "DT_LAST_MODIFIED") AS
  select
fh.PK_FRAME_HISTORY,
fh.PK_FRAME,
fh.PK_LAYER,
fh.PK_JOB,
fh.STR_NAME,
fh.STR_STATE,
fh.INT_MEM_RESERVED,
fh.INT_MEM_MAX_USED,
fh.INT_CORES,
fh.STR_HOST,
fh.INT_EXIT_STATUS,
a.STR_NAME STR_ALLOC_NAME,
a.B_BILLABLE B_ALLOC_BILLABLE,
f.STR_NAME STR_FACILITY_NAME,
fh.INT_TS_STARTED,
fh.INT_TS_STOPPED,
fh.INT_CHECKPOINT_COUNT,
null str_show_name,
fh.dt_last_modified
from frame_history fh, job_history jh, alloc a, facility f
where fh.pk_job = jh.pk_job
and fh.pk_alloc = a.pk_alloc (+)
and a.pk_facility = f.pk_facility (+)
and fh.dt_last_modified >= (
    select dt_begin
    from history_period
)
and fh.dt_last_modified < (
    select dt_end
    from history_period
)
-- SPLIT HERE!
CREATE VIEW "V_HISTORY_JOB" ("PK_JOB", "STR_NAME", "STR_SHOT", "STR_USER", "INT_CORE_TIME_SUCCESS", "INT_CORE_TIME_FAIL", "INT_FRAME_COUNT", "INT_LAYER_COUNT", "INT_WAITING_COUNT", "INT_DEAD_COUNT", "INT_DEPEND_COUNT", "INT_EATEN_COUNT", "INT_SUCCEEDED_COUNT", "INT_RUNNING_COUNT", "INT_MAX_RSS", "B_ARCHIVED", "STR_FACILITY_NAME", "STR_DEPT_NAME", "INT_TS_STARTED", "INT_TS_STOPPED", "STR_SHOW_NAME", "DT_LAST_MODIFIED") AS
  select
jh.PK_JOB,
jh.STR_NAME,
jh.STR_SHOT,
jh.STR_USER,
jh.INT_CORE_TIME_SUCCESS,
jh.INT_CORE_TIME_FAIL,
jh.INT_FRAME_COUNT,
jh.INT_LAYER_COUNT,
jh.INT_WAITING_COUNT,
jh.INT_DEAD_COUNT,
jh.INT_DEPEND_COUNT,
jh.INT_EATEN_COUNT,
jh.INT_SUCCEEDED_COUNT,
jh.INT_RUNNING_COUNT,
jh.INT_MAX_RSS,
jh.B_ARCHIVED,
f.str_name STR_FACILITY_NAME,
d.str_name str_dept_name,
jh.INT_TS_STARTED,
jh.INT_TS_STOPPED,
s.str_name str_show_name,
jh.dt_last_modified
from job_history jh, show s, facility f, dept d
where jh.pk_show   = s.pk_show
and jh.pk_facility = f.pk_facility
and jh.pk_dept     = d.pk_dept
and (
    jh.dt_last_modified >= (
        select dt_begin
        from history_period
    )
    or
    jh.int_ts_stopped = 0
)
-- SPLIT HERE!
CREATE VIEW "V_HISTORY_LAYER" ("PK_LAYER", "PK_JOB", "STR_NAME", "STR_TYPE", "INT_CORES_MIN", "INT_MEM_MIN", "INT_CORE_TIME_SUCCESS", "INT_CORE_TIME_FAIL", "INT_FRAME_COUNT", "INT_LAYER_COUNT", "INT_WAITING_COUNT", "INT_DEAD_COUNT", "INT_DEPEND_COUNT", "INT_EATEN_COUNT", "INT_SUCCEEDED_COUNT", "INT_RUNNING_COUNT", "INT_MAX_RSS", "B_ARCHIVED", "STR_SERVICES", "STR_SHOW_NAME", "DT_LAST_MODIFIED") AS
  select
lh.PK_LAYER,
lh.PK_JOB,
lh.STR_NAME,
lh.STR_TYPE,
lh.INT_CORES_MIN,
lh.INT_MEM_MIN,
lh.INT_CORE_TIME_SUCCESS,
lh.INT_CORE_TIME_FAIL,
lh.INT_FRAME_COUNT,
lh.INT_LAYER_COUNT,
lh.INT_WAITING_COUNT,
lh.INT_DEAD_COUNT,
lh.INT_DEPEND_COUNT,
lh.INT_EATEN_COUNT,
lh.INT_SUCCEEDED_COUNT,
lh.INT_RUNNING_COUNT,
lh.INT_MAX_RSS,
lh.B_ARCHIVED,
lh.STR_SERVICES,
s.str_name str_show_name,
lh.dt_last_modified
from layer_history lh, job_history jh, show s
where lh.pk_job = jh.pk_job
and jh.pk_show  = s.pk_show
and jh.dt_last_modified >= (
    select dt_begin
    from history_period
)
and jh.dt_last_modified < (
    select dt_end
    from history_period
)
-- SPLIT HERE!
CREATE PACKAGE BODY HISTORY AS

    procedure period_shift as
        vTemp date
    begin

        begin

            select dt_end
            into vTemp
            from history_period

            update history_period
            set dt_begin = vTemp,
            dt_end = (
                select sysdate from dual
            )

        exception
            when no_data_found then
                insert into history_period (pk) values (sys_guid())
                select dt_end
                into vTemp
                from history_period
            when others then
                raise
        end

    end period_shift

    procedure period_shift(piEndDate in date) as
        vTemp date
    begin

        begin

            select dt_end
            into vTemp
            from history_period

            update history_period
            set dt_begin = vTemp,
            dt_end = (
                select nvl(piEndDate, sysdate) from dual
            )

        exception
            when no_data_found then
                insert into history_period (pk) values (sys_guid())
                select dt_end
                into vTemp
                from history_period
            when others then
                raise
        end

    end period_shift


    procedure period_clear as
    begin

        delete from history_period
        insert into history_period (pk) values (sys_guid())

    end period_clear

END HISTORY
-- SPLIT HERE!


ALTER TABLE "ACTION" ADD CONSTRAINT "C_ACTION_PK_FILTER" FOREIGN KEY ("PK_FILTER")
	  REFERENCES "FILTER" ("PK_FILTER")
-- SPLIT HERE!
ALTER TABLE "ACTION" ADD CONSTRAINT "C_ACTION_PK_FOLDER" FOREIGN KEY ("PK_FOLDER")
	  REFERENCES "FOLDER" ("PK_FOLDER")
-- SPLIT HERE!
ALTER TABLE "ALLOC" ADD CONSTRAINT "C_ALLOC_PK_FACILITY" FOREIGN KEY ("PK_FACILITY")
	  REFERENCES "FACILITY" ("PK_FACILITY")
-- SPLIT HERE!
ALTER TABLE "COMMENTS" ADD CONSTRAINT "C_COMMENT_PK_HOST" FOREIGN KEY ("PK_HOST")
	  REFERENCES "HOST" ("PK_HOST")
-- SPLIT HERE!
ALTER TABLE "COMMENTS" ADD CONSTRAINT "C_COMMENT_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "FILTER" ADD CONSTRAINT "C_FILTER_PK_SHOW" FOREIGN KEY ("PK_SHOW")
	  REFERENCES "SHOW" ("PK_SHOW")
-- SPLIT HERE!
ALTER TABLE "FOLDER" ADD CONSTRAINT "C_FOLDER_PK_SHOW" FOREIGN KEY ("PK_SHOW")
	  REFERENCES "SHOW" ("PK_SHOW")
-- SPLIT HERE!
ALTER TABLE "FOLDER" ADD CONSTRAINT "C_FOLDER_PK_DEPT" FOREIGN KEY ("PK_DEPT")
	  REFERENCES "DEPT" ("PK_DEPT")
-- SPLIT HERE!
ALTER TABLE "FOLDER_LEVEL" ADD CONSTRAINT "C_FOLDER_LEVEL_PK_FOLDER" FOREIGN KEY ("PK_FOLDER")
	  REFERENCES "FOLDER" ("PK_FOLDER")
-- SPLIT HERE!
ALTER TABLE "FRAME" ADD CONSTRAINT "C_FRAME_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "FRAME" ADD CONSTRAINT "C_FRAME_PK_LAYER" FOREIGN KEY ("PK_LAYER")
	  REFERENCES "LAYER" ("PK_LAYER")
-- SPLIT HERE!
ALTER TABLE "HOST" ADD CONSTRAINT "C_HOST_PK_ALLOC" FOREIGN KEY ("PK_ALLOC")
	  REFERENCES "ALLOC" ("PK_ALLOC")
-- SPLIT HERE!
ALTER TABLE "HOST_STAT" ADD CONSTRAINT "C_HOST_STAT_PK_HOST" FOREIGN KEY ("PK_HOST")
	  REFERENCES "HOST" ("PK_HOST")
-- SPLIT HERE!
ALTER TABLE "JOB" ADD CONSTRAINT "C_JOB_PK_SHOW" FOREIGN KEY ("PK_SHOW")
	  REFERENCES "SHOW" ("PK_SHOW")
-- SPLIT HERE!
ALTER TABLE "JOB" ADD CONSTRAINT "C_JOB_PK_FOLDER" FOREIGN KEY ("PK_FOLDER")
	  REFERENCES "FOLDER" ("PK_FOLDER")
-- SPLIT HERE!
ALTER TABLE "JOB" ADD CONSTRAINT "C_JOB_PK_FACILITY" FOREIGN KEY ("PK_FACILITY")
	  REFERENCES "FACILITY" ("PK_FACILITY")
-- SPLIT HERE!
ALTER TABLE "JOB" ADD CONSTRAINT "C_JOB_PK_DEPT" FOREIGN KEY ("PK_DEPT")
	  REFERENCES "DEPT" ("PK_DEPT")
-- SPLIT HERE!
ALTER TABLE "JOB_ENV" ADD CONSTRAINT "C_JOB_ENV_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "LAYER" ADD CONSTRAINT "C_LAYER_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "LAYER_ENV" ADD CONSTRAINT "C_LAYER_ENV_PK_LAYER" FOREIGN KEY ("PK_LAYER")
	  REFERENCES "LAYER" ("PK_LAYER")
-- SPLIT HERE!
ALTER TABLE "LAYER_ENV" ADD CONSTRAINT "C_LAYER_ENV_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "LAYER_RESOURCE" ADD CONSTRAINT "C_LAYER_RESOURCE_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "LAYER_RESOURCE" ADD CONSTRAINT "C_LAYER_RESOURCE_PK_LAYER" FOREIGN KEY ("PK_LAYER")
	  REFERENCES "LAYER" ("PK_LAYER")
-- SPLIT HERE!
ALTER TABLE "LAYER_STAT" ADD CONSTRAINT "C_LAYER_STAT_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "LAYER_STAT" ADD CONSTRAINT "C_LAYER_STAT_PK_LAYER" FOREIGN KEY ("PK_LAYER")
	  REFERENCES "LAYER" ("PK_LAYER")
-- SPLIT HERE!
ALTER TABLE "LAYER_USAGE" ADD CONSTRAINT "C_LAYER_USAGE_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "LAYER_USAGE" ADD CONSTRAINT "C_LAYER_USAGE_PK_LAYER" FOREIGN KEY ("PK_LAYER")
	  REFERENCES "LAYER" ("PK_LAYER")
-- SPLIT HERE!
ALTER TABLE "MATCHER" ADD CONSTRAINT "C_MATCHER_PK_FILTER" FOREIGN KEY ("PK_FILTER")
	  REFERENCES "FILTER" ("PK_FILTER")
-- SPLIT HERE!
ALTER TABLE "PROC" ADD CONSTRAINT "C_PROC_PK_FRAME" FOREIGN KEY ("PK_FRAME")
	  REFERENCES "FRAME" ("PK_FRAME")
-- SPLIT HERE!
ALTER TABLE "PROC" ADD CONSTRAINT "C_PROC_PK_HOST" FOREIGN KEY ("PK_HOST")
	  REFERENCES "HOST" ("PK_HOST")
-- SPLIT HERE!
ALTER TABLE "SUBSCRIPTION" ADD CONSTRAINT "C_SUBSCRIPTION_PK_ALLOC" FOREIGN KEY ("PK_ALLOC")
	  REFERENCES "ALLOC" ("PK_ALLOC")
-- SPLIT HERE!
ALTER TABLE "SUBSCRIPTION" ADD CONSTRAINT "C_SUBSCRIPTION_PK_SHOW" FOREIGN KEY ("PK_SHOW")
	  REFERENCES "SHOW" ("PK_SHOW")
-- SPLIT HERE!
ALTER TABLE "JOB_STAT" ADD CONSTRAINT "C_JOB_STAT_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "JOB_RESOURCE" ADD CONSTRAINT "C_JOB_RESOURCE_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "JOB_USAGE" ADD CONSTRAINT "C_JOB_USAGE_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "JOB_HISTORY" ADD CONSTRAINT "C_JOB_HISTORY_PK_FACILITY" FOREIGN KEY ("PK_FACILITY")
	  REFERENCES "FACILITY" ("PK_FACILITY")
-- SPLIT HERE!
ALTER TABLE "JOB_HISTORY" ADD CONSTRAINT "C_JOB_HISTORY_PK_DEPT" FOREIGN KEY ("PK_DEPT")
	  REFERENCES "DEPT" ("PK_DEPT")
-- SPLIT HERE!
ALTER TABLE "JOB_HISTORY" ADD CONSTRAINT "C_JOB_HISTORY_PK_SHOW" FOREIGN KEY ("PK_SHOW")
	  REFERENCES "SHOW" ("PK_SHOW")
-- SPLIT HERE!
ALTER TABLE "LAYER_HISTORY" ADD CONSTRAINT "C_LAYER_HISTORY_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB_HISTORY" ("PK_JOB") ON DELETE CASCADE
-- SPLIT HERE!
ALTER TABLE "JOB_POST" ADD CONSTRAINT "C_JOB_POST_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "JOB_POST" ADD CONSTRAINT "C_JOB_POST_PK_POST_JOB" FOREIGN KEY ("PK_POST_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "SHOW_ALIAS" ADD CONSTRAINT "C_SHOW_ALIAS_PK_SHOW" FOREIGN KEY ("PK_SHOW")
	  REFERENCES "SHOW" ("PK_SHOW")
-- SPLIT HERE!
ALTER TABLE "FOLDER_RESOURCE" ADD CONSTRAINT "C_FOLDER_RESOURCE_PK_FOLDER" FOREIGN KEY ("PK_FOLDER")
	  REFERENCES "FOLDER" ("PK_FOLDER")
-- SPLIT HERE!
ALTER TABLE "JOB_MEM" ADD CONSTRAINT "C_JOB_MEM_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "LAYER_MEM" ADD CONSTRAINT "C_LAYER_MEM_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "LAYER_MEM" ADD CONSTRAINT "C_LAYER_MEM_PK_LAYER" FOREIGN KEY ("PK_LAYER")
	  REFERENCES "LAYER" ("PK_LAYER")
-- SPLIT HERE!
ALTER TABLE "POINT" ADD CONSTRAINT "C_POINT_PK_DEPT" FOREIGN KEY ("PK_DEPT")
	  REFERENCES "DEPT" ("PK_DEPT")
-- SPLIT HERE!
ALTER TABLE "POINT" ADD CONSTRAINT "C_POINT_PK_SHOW" FOREIGN KEY ("PK_SHOW")
	  REFERENCES "SHOW" ("PK_SHOW")
-- SPLIT HERE!
ALTER TABLE "TASK" ADD CONSTRAINT "C_TASK_PK_POINT" FOREIGN KEY ("PK_POINT")
	  REFERENCES "POINT" ("PK_POINT")
-- SPLIT HERE!
ALTER TABLE "JOB_LOCAL" ADD CONSTRAINT "C_JOB_LOCAL_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "JOB_LOCAL" ADD CONSTRAINT "C_JOB_LOCAL_PK_HOST" FOREIGN KEY ("PK_HOST")
	  REFERENCES "HOST" ("PK_HOST")
-- SPLIT HERE!
ALTER TABLE "HOST_LOCAL" ADD CONSTRAINT "C_HOST_LOCAL_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "HOST_LOCAL" ADD CONSTRAINT "C_HOST_LOCAL_PK_HOST" FOREIGN KEY ("PK_HOST")
	  REFERENCES "HOST" ("PK_HOST")
-- SPLIT HERE!
ALTER TABLE "OWNER" ADD CONSTRAINT "C_OWNER_PK_SHOW" FOREIGN KEY ("PK_SHOW")
	  REFERENCES "SHOW" ("PK_SHOW")
-- SPLIT HERE!
ALTER TABLE "DEED" ADD CONSTRAINT "C_DEED_PK_HOST" FOREIGN KEY ("PK_HOST")
	  REFERENCES "HOST" ("PK_HOST")
-- SPLIT HERE!
ALTER TABLE "SHOW_SERVICE" ADD CONSTRAINT "C_SHOW_SERVICE_PK_SHOW" FOREIGN KEY ("PK_SHOW")
	  REFERENCES "SHOW" ("PK_SHOW")
-- SPLIT HERE!
ALTER TABLE "LAYER_OUTPUT" ADD CONSTRAINT "C_LAYER_OUTPUT_PK_LAYER" FOREIGN KEY ("PK_LAYER")
	  REFERENCES "LAYER" ("PK_LAYER")
-- SPLIT HERE!
ALTER TABLE "LAYER_OUTPUT" ADD CONSTRAINT "C_LAYER_OUTPUT_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB" ("PK_JOB")
-- SPLIT HERE!
ALTER TABLE "FRAME_HISTORY" ADD CONSTRAINT "C_FRAME_HISTORY_PK_JOB" FOREIGN KEY ("PK_JOB")
	  REFERENCES "JOB_HISTORY" ("PK_JOB") ON DELETE CASCADE
-- SPLIT HERE!
ALTER TABLE "FRAME_HISTORY" ADD CONSTRAINT "C_FRAME_HISTORY_PK_LAYER" FOREIGN KEY ("PK_LAYER")
	  REFERENCES "LAYER_HISTORY" ("PK_LAYER") ON DELETE CASCADE
-- SPLIT HERE!
ALTER TABLE "FRAME_HISTORY" ADD CONSTRAINT "C_FRAME_HISTORY_PK_ALLOC" FOREIGN KEY ("PK_ALLOC")
	  REFERENCES "ALLOC" ("PK_ALLOC")
-- SPLIT HERE!

CREATE TRIGGER tbiu_layer_history
before insert or update
on layer_history
referencing new as new old as old
for each row
begin
    :new.dt_last_modified := sysdate;
end;
-- SPLIT HERE!

CREATE TRIGGER "AFTER_JOB_MOVED" AFTER UPDATE ON job
FOR EACH ROW
  WHEN (NEW.pk_folder != OLD.pk_folder) DECLARE
    int_core_count NUMERIC(16,0);
BEGIN
  SELECT int_cores INTO int_core_count
  FROM job_resource WHERE pk_job = :new.pk_job;

  IF int_core_count > 0 THEN
    UPDATE folder_resource  SET int_cores = int_cores + int_core_count
    WHERE pk_folder = :new.pk_folder;

    UPDATE folder_resource  SET int_cores = int_cores - int_core_count
    WHERE pk_folder = :old.pk_folder;
  END IF;
END;
-- SPLIT HERE!

CREATE TRIGGER "BEFORE_DELETE_JOB" BEFORE DELETE ON job
FOR EACH ROW
DECLARE
    TYPE StatType IS RECORD (
        int_core_time_success NUMERIC(38),
        int_core_time_fail NUMERIC(38),
        int_waiting_count NUMERIC(38),
        int_dead_count NUMERIC(38),
        int_depend_count NUMERIC(38),
        int_eaten_count NUMERIC(38),
        int_succeeded_count NUMERIC(38),
        int_running_count NUMERIC(38),
        int_max_rss NUMERIC(38)
    );
    js StatType;

BEGIN
    SELECT
        job_usage.int_core_time_success,
        job_usage.int_core_time_fail,
        job_stat.int_waiting_count,
        job_stat.int_dead_count,
        job_stat.int_depend_count,
        job_stat.int_eaten_count,
        job_stat.int_succeeded_count,
        job_stat.int_running_count,
        job_mem.int_max_rss
    INTO
        js
    FROM
        job_mem,
        job_usage,
        job_stat
    WHERE
        job_usage.pk_job = job_mem.pk_job
    AND
        job_stat.pk_job = job_mem.pk_job
    AND
        job_mem.pk_job = :old.pk_job;

    UPDATE
        job_history
    SET
        pk_dept = :old.pk_dept,
        int_core_time_success = js.int_core_time_success,
        int_core_time_fail = js.int_core_time_fail,
        int_frame_count = :old.int_frame_count,
        int_layer_count = :old.int_layer_count,
        int_waiting_count = js.int_waiting_count,
        int_dead_count = js.int_dead_count,
        int_depend_count = js.int_depend_count,
        int_eaten_count = js.int_eaten_count,
        int_succeeded_count = js.int_succeeded_count,
        int_running_count = js.int_running_count,
        int_max_rss = js.int_max_rss,
        b_archived = 1,
        int_ts_stopped = nvl(epoch(:old.ts_stopped), epoch(systimestamp))
    WHERE
        pk_job = :old.pk_job;

    delete from depend where pk_job_depend_on=:old.pk_job or pk_job_depend_er=:old.pk_job;
    delete from frame where pk_job=:old.pk_job;
    delete from layer where pk_job=:old.pk_job;
    delete from job_env WHERE pk_job=:old.pk_job;
    delete from job_stat WHERE pk_job=:old.pk_job;
    delete from job_resource WHERE pk_job=:old.pk_job;
    delete from job_usage WHERE pk_job=:old.pk_job;
    delete from job_mem WHERE pk_job=:old.pk_job;
    delete from comments WHERE pk_job=:old.pk_job;

END;
-- SPLIT HERE!

CREATE TRIGGER "AFTER_JOB_FINISHED" AFTER UPDATE ON job
FOR EACH ROW
      WHEN (old.str_state = 'Pending' AND new.str_state = 'Finished') DECLARE
    ts NUMERIC(12,0) := epoch(systimestamp);
    TYPE StatType IS RECORD (
        int_core_time_success NUMERIC(38),
        int_core_time_fail NUMERIC(38),
        int_waiting_count NUMERIC(38),
        int_dead_count NUMERIC(38),
        int_depend_count NUMERIC(38),
        int_eaten_count NUMERIC(38),
        int_succeeded_count NUMERIC(38),
        int_running_count NUMERIC(38),
        int_max_rss NUMERIC(38)
    );

    TYPE LayerStatType IS RECORD (
        int_core_time_success NUMERIC(38),
        int_core_time_fail NUMERIC(38),
        int_total_count NUMERIC(38),
        int_waiting_count NUMERIC(38),
        int_dead_count NUMERIC(38),
        int_depend_count NUMERIC(38),
        int_eaten_count NUMERIC(38),
        int_succeeded_count NUMERIC(38),
        int_running_count NUMERIC(38),
        int_max_rss NUMERIC(38)
    );
    js StatType;
    ls LayerStatType;
BEGIN
    SELECT
        job_usage.int_core_time_success,
        job_usage.int_core_time_fail,
        job_stat.int_waiting_count,
        job_stat.int_dead_count,
        job_stat.int_depend_count,
        job_stat.int_eaten_count,
        job_stat.int_succeeded_count,
        job_stat.int_running_count,
        job_mem.int_max_rss
    INTO
        js
    FROM
        job_mem,
        job_usage,
        job_stat
    WHERE
        job_usage.pk_job = job_mem.pk_job
    AND
        job_stat.pk_job = job_mem.pk_job
    AND
        job_mem.pk_job = :new.pk_job;

    UPDATE
        job_history
    SET
        pk_dept = :new.pk_dept,
        int_core_time_success = js.int_core_time_success,
        int_core_time_fail = js.int_core_time_fail,
        int_frame_count = :new.int_frame_count,
        int_layer_count = :new.int_layer_count,
        int_waiting_count = js.int_waiting_count,
        int_dead_count = js.int_dead_count,
        int_depend_count = js.int_depend_count,
        int_eaten_count = js.int_eaten_count,
        int_succeeded_count = js.int_succeeded_count,
        int_running_count = js.int_running_count,
        int_max_rss = js.int_max_rss,
        int_ts_stopped = ts
    WHERE
        pk_job = :new.pk_job;

    FOR one_layer in (SELECT pk_layer from layer where pk_job = :new.pk_job) LOOP
        SELECT
            layer_usage.int_core_time_success,
            layer_usage.int_core_time_fail,
            layer_stat.int_total_count,
            layer_stat.int_waiting_count,
            layer_stat.int_dead_count,
            layer_stat.int_depend_count,
            layer_stat.int_eaten_count,
            layer_stat.int_succeeded_count,
            layer_stat.int_running_count,
            layer_mem.int_max_rss
        INTO
            ls
        FROM
            layer_mem,
            layer_usage,
            layer_stat
        WHERE
            layer_usage.pk_layer = layer_mem.pk_layer
        AND
            layer_stat.pk_layer = layer_mem.pk_layer
        AND
            layer_mem.pk_layer = one_layer.pk_layer;

        UPDATE
            layer_history
        SET
            int_core_time_success = ls.int_core_time_success,
            int_core_time_fail = ls.int_core_time_fail,
            int_frame_count = ls.int_total_count,
            int_waiting_count = ls.int_waiting_count,
            int_dead_count = ls.int_dead_count,
            int_depend_count = ls.int_depend_count,
            int_eaten_count = ls.int_eaten_count,
            int_succeeded_count = ls.int_succeeded_count,
            int_running_count = ls.int_running_count,
            int_max_rss = ls.int_max_rss
        WHERE
            pk_layer = one_layer.pk_layer;
    END LOOP;

    /**
     * Delete any local core assignements from this job.
     **/
    DELETE FROM job_local WHERE pk_job=:new.pk_job;

END;
-- SPLIT HERE!

CREATE TRIGGER "AFTER_INSERT_JOB" AFTER INSERT ON job
FOR EACH ROW
BEGIN
    INSERT INTO job_stat (pk_job_stat,pk_job) VALUES(:new.pk_job,:new.pk_job);
    INSERT INTO job_resource (pk_job_resource,pk_job) VALUES(:new.pk_job,:new.pk_job);
    INSERT INTO job_usage (pk_job_usage,pk_job) VALUES(:new.pk_job,:new.pk_job);
    INSERT INTO job_mem (pk_job_mem,pk_job) VALUES (:new.pk_job,:new.pk_job);

    INSERT INTO job_history
        (pk_job, pk_show, pk_facility, pk_dept, str_name, str_shot, str_user, int_ts_started)
    VALUES
        (:new.pk_job, :new.pk_show, :new.pk_facility, :new.pk_dept,
         :new.str_name, :new.str_shot, :new.str_user, epoch(systimestamp));
END;
-- SPLIT HERE!

CREATE TRIGGER "AFTER_JOB_DEPT_UPDATE" AFTER UPDATE ON job
FOR EACH ROW
  WHEN (NEW.pk_dept != OLD.pk_dept AND new.str_state='Pending') DECLARE
    int_running_cores NUMERIC(16,0);
BEGIN
  /**
  * Handles the accounting for moving a job between departments.
  **/
  SELECT int_cores INTO int_running_cores
    FROM job_resource WHERE pk_job = :new.pk_job;

  IF int_running_cores > 0 THEN
    UPDATE point SET int_cores = int_cores + int_running_cores
        WHERE pk_dept = :new.pk_dept AND pk_show = :new.pk_show;

    UPDATE point  SET int_cores = int_cores - int_running_cores
        WHERE pk_dept = :old.pk_dept AND pk_show = :old.pk_show;
  END IF;

END;
-- SPLIT HERE!

CREATE TRIGGER "VERIFY_HOST_LOCAL" BEFORE UPDATE ON host_local
FOR EACH ROW
   WHEN ((NEW.int_cores_max = OLD.int_cores_max AND NEW.int_mem_max = OLD.int_mem_max) AND
(NEW.int_cores_idle != OLD.int_cores_idle OR NEW.int_mem_idle != OLD.int_mem_idle)) BEGIN
    /**
    * Check to see if the new cores exceeds max cores.  This check is only
    * done if NEW.int_max_cores is equal to OLD.int_max_cores and
    * NEW.int_cores > OLD.int_cores, otherwise this error will be thrown
    * when people lower the max.
    **/
    IF :NEW.int_cores_idle < 0 THEN
        Raise_application_error(-20021, 'host local doesnt have enough idle cores.');
    END IF;

    IF :NEW.int_mem_idle < 0 THEN
        Raise_application_error(-20021, 'host local doesnt have enough idle memory');
    END IF;

END;
-- SPLIT HERE!

CREATE TRIGGER "TIER_HOST_LOCAL" BEFORE UPDATE ON host_local
FOR EACH ROW
BEGIN
    :new.float_tier := tier(:new.int_cores_max - :new.int_cores_idle,:new.int_cores_max);
END;
-- SPLIT HERE!

CREATE TRIGGER "AFTER_INSERT_LAYER" AFTER INSERT ON layer
FOR EACH ROW
BEGIN

    INSERT INTO layer_stat (pk_layer_stat, pk_layer, pk_job) VALUES (:new.pk_layer, :new.pk_layer, :new.pk_job);
    INSERT INTO layer_resource (pk_layer_resource, pk_layer, pk_job) VALUES (:new.pk_layer, :new.pk_layer, :new.pk_job);
    INSERT INTO layer_usage (pk_layer_usage, pk_layer, pk_job) VALUES (:new.pk_layer, :new.pk_layer, :new.pk_job);
    INSERT INTO layer_mem (pk_layer_mem, pk_layer, pk_job) VALUES (:new.pk_layer, :new.pk_layer, :new.pk_job);

    INSERT INTO layer_history
        (pk_layer, pk_job, str_name, str_type, int_cores_min, int_mem_min, b_archived, str_services)
    VALUES
        (:new.pk_layer, :new.pk_job, :new.str_name, :new.str_type, :new.int_cores_min, :new.int_mem_min, 0, :new.str_services);
END;
-- SPLIT HERE!

CREATE TRIGGER "BEFORE_DELETE_LAYER" BEFORE DELETE ON layer
FOR EACH ROW
DECLARE
    TYPE StatType IS RECORD (
        int_core_time_success NUMERIC(38),
        int_core_time_fail NUMERIC(38),
        int_total_count NUMERIC(38),
        int_waiting_count NUMERIC(38),
        int_dead_count NUMERIC(38),
        int_depend_count NUMERIC(38),
        int_eaten_count NUMERIC(38),
        int_succeeded_count NUMERIC(38),
        int_running_count NUMERIC(38),
        int_max_rss NUMERIC(38)
    );
    js StatType;

BEGIN
    SELECT
        layer_usage.int_core_time_success,
        layer_usage.int_core_time_fail,
        layer_stat.int_total_count,
        layer_stat.int_waiting_count,
        layer_stat.int_dead_count,
        layer_stat.int_depend_count,
        layer_stat.int_eaten_count,
        layer_stat.int_succeeded_count,
        layer_stat.int_running_count,
        layer_mem.int_max_rss
    INTO
        js
    FROM
        layer_mem,
        layer_usage,
        layer_stat
    WHERE
        layer_usage.pk_layer = layer_mem.pk_layer
    AND
        layer_stat.pk_layer = layer_mem.pk_layer
    AND
        layer_mem.pk_layer = :old.pk_layer;

    UPDATE
        layer_history
    SET
        int_core_time_success = js.int_core_time_success,
        int_core_time_fail = js.int_core_time_fail,
        int_frame_count = js.int_total_count,
        int_waiting_count = js.int_waiting_count,
        int_dead_count = js.int_dead_count,
        int_depend_count = js.int_depend_count,
        int_eaten_count = js.int_eaten_count,
        int_succeeded_count = js.int_succeeded_count,
        int_running_count = js.int_running_count,
        int_max_rss = js.int_max_rss,
        b_archived = 1
    WHERE
        pk_layer = :old.pk_layer;

    delete from layer_resource where pk_layer=:old.pk_layer;
    delete from layer_stat where pk_layer=:old.pk_layer;
    delete from layer_usage where pk_layer=:old.pk_layer;
    delete from layer_env where pk_layer=:old.pk_layer;
    delete from layer_mem where pk_layer=:old.pk_layer;
    delete from layer_output where pk_layer=:old.pk_layer;
END;
-- SPLIT HERE!

CREATE TRIGGER tbiu_job_history
before insert or update
on job_history
referencing new as new old as old
for each row
begin
    :new.dt_last_modified := sysdate;
end;
-- SPLIT HERE!

CREATE TRIGGER "VERIFY_HOST_RESOURCES" BEFORE UPDATE ON host
FOR EACH ROW
   WHEN (new.int_cores_idle != old.int_cores_idle OR new.int_mem_idle != old.int_mem_idle) BEGIN
    IF :new.int_cores_idle < 0 THEN
        Raise_application_error(-20011, 'unable to allocate additional core units');
    END IF;

    If :new.int_mem_idle < 0 THEN
        Raise_application_error(-20012, 'unable to allocate additional memory');
    END IF;

    If :new.int_gpu_idle < 0 THEN
        Raise_application_error(-20013, 'unable to allocate additional gpu memory');
    END IF;

END;
-- SPLIT HERE!

CREATE TRIGGER "BEFORE_DELETE_HOST" BEFORE DELETE ON host
FOR EACH ROW
BEGIN
    delete from host_stat WHERE pk_host = :old.pk_host;
    delete from host_tag WHERE pk_host = :old.pk_host;
    delete from deed WHERE pk_host = :old.pk_host;
END;
-- SPLIT HERE!

CREATE TRIGGER "VERIFY_JOB_RESOURCES" BEFORE UPDATE ON job_resource
FOR EACH ROW
  WHEN ( NEW.int_max_cores = OLD.int_max_cores AND NEW.int_cores > OLD.int_cores) BEGIN
    /**
    * Check to see if the new cores exceeds max cores.  This check is only
    * done if NEW.int_max_cores is equal to OLD.int_max_cores and
    * NEW.int_cores > OLD.int_cores, otherwise this error will be thrown
    * at the wrong time.
    **/
    IF :NEW.int_cores > :NEW.int_max_cores THEN
        Raise_application_error(-20021, 'job has exceeded max cores');
    END IF;
END;
-- SPLIT HERE!

CREATE TRIGGER "TIER_JOB" BEFORE UPDATE ON job_resource
FOR EACH ROW
BEGIN
    /** calculates new tier **/
    :new.float_tier := tier(:new.int_cores,:new.int_min_cores);
END;
-- SPLIT HERE!

CREATE TRIGGER "VERIFY_JOB_LOCAL" BEFORE UPDATE ON job_local
FOR EACH ROW
  WHEN ( NEW.int_max_cores = OLD.int_max_cores AND NEW.int_cores > OLD.int_cores) BEGIN
    /**
    * Check to see if the new cores exceeds max cores.  This check is only
    * done if NEW.int_max_cores is equal to OLD.int_max_cores and
    * NEW.int_cores > OLD.int_cores, otherwise this error will be thrown
    * when people lower the max.
    **/
    IF :NEW.int_cores > :NEW.int_max_cores THEN
        Raise_application_error(-20021, 'job local has exceeded max cores');
    END IF;
END;
-- SPLIT HERE!

CREATE TRIGGER "TIER_FOLDER" BEFORE UPDATE ON folder_resource
FOR EACH ROW
BEGIN
    /** calculates new tier **/
    :new.float_tier := soft_tier(:new.int_cores,:new.int_min_cores);
END;
-- SPLIT HERE!

CREATE TRIGGER "BEFORE_DELETE_FOLDER" BEFORE DELETE ON folder
FOR EACH ROW
BEGIN
    DELETE FROM folder_level WHERE pk_folder = :old.pk_folder;
    DELETE FROM folder_resource WHERE pk_folder = :old.pk_folder;
END;
-- SPLIT HERE!

CREATE TRIGGER "AFTER_INSERT_FOLDER" AFTER INSERT ON folder
FOR EACH ROW
DECLARE
    int_level NUMERIC(16,0) :=0;
BEGIN
    IF :new.pk_parent_folder IS NOT NULL THEN
        SELECT folder_level.int_level + 1 INTO int_level FROM folder_level WHERE pk_folder = :new.pk_parent_folder;
    END IF;
    INSERT INTO folder_level (pk_folder_level,pk_folder,int_level) VALUES (:new.pk_folder, :new.pk_folder, int_level);
    INSERT INTO folder_resource (pk_folder_resource,pk_folder) VALUES (:new.pk_folder, :new.pk_folder);
END;
-- SPLIT HERE!

CREATE TRIGGER "BEFORE_INSERT_FOLDER" BEFORE INSERT ON folder
FOR EACH ROW
BEGIN
    IF :new.pk_parent_folder IS NULL THEN
        :new.b_default := 1;
    END IF;
END;
-- SPLIT HERE!

CREATE TRIGGER "BEFORE_INSERT_PROC" BEFORE INSERT ON proc
FOR EACH ROW
BEGIN
  IF :new.int_cores_reserved <= 0 THEN
    Raise_application_error(-20010, 'failed to allocate proc, tried to allocate 0 cores');
  END IF;
END;
-- SPLIT HERE!

CREATE TRIGGER "UPDATE_PROC_UPDATE_LAYER" AFTER UPDATE ON proc
FOR EACH ROW
  WHEN (new.pk_layer != old.pk_layer) BEGIN
     FOR lr IN (
        SELECT
          pk_layer
        FROM
          layer_stat
        WHERE
          pk_layer IN (:old.pk_layer,:new.pk_layer)
        ORDER BY layer_stat.pk_layer DESC
        ) LOOP

      IF lr.pk_layer = :old.pk_layer THEN

        UPDATE layer_resource SET
          int_cores = int_cores - :old.int_cores_reserved
        WHERE
          pk_layer = :old.pk_layer;

      ELSE

        UPDATE layer_resource SET
          int_cores = int_cores + :new.int_cores_reserved
       WHERE
          pk_layer = :new.pk_layer;
       END IF;

    END LOOP;
END;
-- SPLIT HERE!

CREATE TRIGGER "UPGRADE_PROC_MEMORY_USAGE" AFTER UPDATE ON proc
FOR EACH ROW
  WHEN (NEW.int_mem_reserved != OLD.int_mem_reserved) BEGIN
    UPDATE host SET
        int_mem_idle = int_mem_idle - (:new.int_mem_reserved - :old.int_mem_reserved)
    WHERE
        pk_host = :new.pk_host;
END;
-- SPLIT HERE!

CREATE TRIGGER "UPDATE_FRAME_WAIT_TO_DEP" BEFORE UPDATE ON frame
FOR EACH ROW
  WHEN (NEW.int_depend_count > 0 AND NEW.str_state IN ('Dead','Succeeded','Waiting','Checkpoint')) BEGIN
    :NEW.str_state := 'Depend';
    :NEW.ts_updated := systimestamp;
    :NEW.int_version := :NEW.int_version + 1;
END;
-- SPLIT HERE!

CREATE TRIGGER "UPDATE_FRAME_EATEN" BEFORE UPDATE ON frame
FOR EACH ROW
  WHEN (NEW.str_state='Eaten' AND OLD.str_state='Succeeded') BEGIN
    :NEW.str_state :='Succeeded';
END;
-- SPLIT HERE!

CREATE TRIGGER "UPDATE_FRAME_DEP_TO_WAIT" BEFORE UPDATE ON frame
FOR EACH ROW
  WHEN (OLD.int_depend_count > 0 AND NEW.int_depend_count < 1 AND OLD.str_state='Depend') BEGIN
    :NEW.str_state := 'Waiting';
    :NEW.ts_updated := systimestamp;
    :NEW.int_version := :NEW.int_version + 1;
END;
-- SPLIT HERE!

CREATE TRIGGER "FRAME_HISTORY_OPEN" AFTER UPDATE ON frame
FOR EACH ROW
   WHEN (NEW.str_state != OLD.str_state) DECLARE
  str_pk_alloc VARCHAR2(36) := null;
  int_checkpoint integer := 0;
BEGIN

    IF :old.str_state = 'Running' THEN

        IF :new.int_exit_status = 299 THEN

          EXECUTE IMMEDIATE
          'DELETE FROM
              frame_history
          WHERE
              int_ts_stopped = 0 AND pk_frame=:1'
          USING
            :new.pk_frame;

        ELSE
          If :new.str_state = 'Checkpoint' THEN
              int_checkpoint := 1;
          END IF;

          EXECUTE IMMEDIATE
          'UPDATE
              frame_history
          SET
              int_mem_max_used=:1,
              int_ts_stopped=:2,
              int_exit_status=:3,
              int_checkpoint_count=:4
          WHERE
              int_ts_stopped = 0 AND pk_frame=:5'
          USING
              :new.int_mem_max_used,
              epoch(systimestamp),
              :new.int_exit_status,
              int_checkpoint,
              :new.pk_frame;
        END IF;
    END IF;

    IF :new.str_state = 'Running' THEN

      SELECT pk_alloc INTO str_pk_alloc FROM host WHERE str_name=:new.str_host;

      EXECUTE IMMEDIATE
        'INSERT INTO
            frame_history
        (
            pk_frame,
            pk_layer,
            pk_job,
            str_name,
            str_state,
            int_cores,
            int_mem_reserved,
            str_host,
            int_ts_started,
            pk_alloc
         )
         VALUES
            (:1,:2,:3,:4,:5,:6,:7,:8,:9,:10)'
         USING :new.pk_frame,
            :new.pk_layer,
            :new.pk_job,
            :new.str_name,
            'Running',
            :new.int_cores,
            :new.int_mem_reserved,
            :new.str_host,
            epoch(systimestamp),
            str_pk_alloc;
    END IF;


EXCEPTION
    /**
    * When we first roll this out then job won't be in the historical
    * table, so frames on existing jobs will fail unless we catch
    * and eat the exceptions.
    **/
    WHEN OTHERS THEN
        NULL;
END;
-- SPLIT HERE!

CREATE TRIGGER "UPDATE_FRAME_CHECKPOINT_STATE" BEFORE UPDATE ON frame
FOR EACH ROW
  WHEN (NEW.str_state='Waiting' AND OLD.str_state='Running' AND NEW.str_checkpoint_state IN ('Enabled', 'Copying')) BEGIN
    :NEW.str_state :='Checkpoint';
END;
-- SPLIT HERE!

CREATE TRIGGER "UPDATE_FRAME_STATUS_COUNTS" AFTER UPDATE ON frame
FOR EACH ROW
  WHEN (old.str_state != 'Setup' AND old.str_state != new.str_state) DECLARE
    s_old_status_col VARCHAR2(32);
    s_new_status_col VARCHAR2(32);
BEGIN
    s_old_status_col := 'int_' || :old.str_state || '_count';
    s_new_status_col := 'int_' || :new.str_state || '_count';

    EXECUTE IMMEDIATE 'UPDATE layer_stat SET ' || s_old_status_col || '=' || s_old_status_col || ' -1, '
        || s_new_status_col || ' = ' || s_new_status_col || '+1 WHERE pk_layer=:1' USING :new.pk_layer;

    EXECUTE IMMEDIATE 'UPDATE job_stat SET ' || s_old_status_col || '=' || s_old_status_col || ' -1, '
        || s_new_status_col || ' = ' || s_new_status_col || '+1 WHERE pk_job=:1' USING :new.pk_job;
END;
-- SPLIT HERE!

CREATE TRIGGER "VERIFY_SUBSCRIPTION" BEFORE UPDATE ON subscription
FOR EACH ROW
  WHEN ( NEW.int_burst = OLD.int_burst AND NEW.int_cores > OLD.int_cores) BEGIN
    /**
    * Check to see if adding more procs will push the show over
    * its subscription size.  This check is only done when
    * new.int_burst = old.int_burst and new.int_cores > old.int cores,
    * otherwise this error would be thrown at the wrong time.
    **/
    IF :NEW.int_cores > :NEW.int_burst THEN
        Raise_application_error(-20022, 'subscription has exceeded burst size');
    END IF;
END;
-- SPLIT HERE!

CREATE TRIGGER "TIER_SUBSCRIPTION" BEFORE UPDATE ON subscription
FOR EACH ROW
BEGIN
    /* calcultes a soft tier */
    :new.float_tier := tier(:new.int_cores, :new.int_size);
END;
-- SPLIT HERE!

CREATE TRIGGER "POINT_TIER" BEFORE UPDATE ON point
FOR EACH ROW
BEGIN
    /* calcultes a soft tier */
    :new.float_tier := soft_tier(:new.int_cores, :new.int_min_cores);
END;
-- SPLIT HERE!

CREATE TRIGGER TBIU_FRAME_HISTORY
before INSERT OR UPDATE
ON frame_history
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH row
BEGIN
	:new.dt_last_modified := sysdate;
END;
-- SPLIT HERE!

CALL ctx_ddl.create_index_set('tag_set')
-- SPLIT HERE!
CALL ctx_ddl.add_index('tag_set','str_name')
-- SPLIT HERE!
create index i_host_str_tags ON host (str_tags) INDEXTYPE IS ctxsys.ctxcat parameters ('INDEX SET tag_set')
